
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | pengqq&#39;s blog</title>
    <meta name="author" content="pengqq" />
    <meta name="description" content="写代码好累..." />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>







<script src="https://s4.zstatic.net/ajax/libs/twikoo/1.6.31/twikoo.all.min.js"></script>



<link rel="stylesheet" href="/css/main.css" />

    <script src="/js/anime.min.js"></script>
    <script src="/js/fireworks.js"></script>
    <script src="/js/sakura.js"></script>
    <link rel="stylesheet" href="/css/cursor.css" />
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PENGQQ&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PENGQQ&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/11
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="golang基础笔记">Golang基础笔记</span></h1><span id="more"></span>

<p>[TOC]</p>
<!-- toc -->

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a><ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85">环境安装</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91">关于编译</a></li>
</ul>
</li>
<li><a href="#%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80">变量基础</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a><ul>
<li><a href="#%E5%88%A4%E6%96%AD">判断</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a></li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">复合数据类型</a><ul>
<li><a href="#array-%E6%95%B0%E7%BB%84">Array 数组</a></li>
<li><a href="#slice-%E5%88%87%E7%89%87">Slice 切片</a></li>
<li><a href="#map-%E5%AD%97%E5%85%B8">Map 字典</a></li>
<li><a href="#pointer-%E6%8C%87%E9%92%88">Pointer 指针</a></li>
<li><a href="#function-%E5%87%BD%E6%95%B0">Function 函数</a></li>
<li><a href="#struct-%E7%BB%93%E6%9E%84%E4%BD%93">Struct 结构体</a></li>
<li><a href="#channel-%E9%80%9A%E9%81%93">Channel 通道</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E8%80%85">方法&amp;接收者</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3-interface">接口 <code>Interface</code></a></li>
</ul>
</li>
<li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8">包管理器</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a></li>
<li><a href="#%E5%B7%A5%E5%85%B7-tools">工具 <code>Tools</code></a></li>
</ul>
<!-- tocstop -->

<h2><span id="开发环境">开发环境</span></h2><h3><span id="环境安装">环境安装</span></h3><p><code>Linux</code>安装：</p>
<pre><code class="language-shell">
# 下载指定版本
wget https://golang.google.cn/dl/go1.21.1.linux-amd64.tar.gz

# 解压到指定目录
tar -C /usr/local/ -zxvf go1.21.1.linux-amd64.tar.gz

# 配置环境变量 ~/.bashrc or ~/.profile 添加
export GOROOT=/usr/local/go/bin
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT

# 重新加载配置
source .profile

# 验证
go version
</code></pre>
<p>如果是 <code>Windows</code> 下载安装然后同理配置相关的环境变量即可。</p>
<p>需要注意的是，可以在 <code>GOPATH</code> 目录下新建三个目录 <code>bin</code> 、<code>src</code>、<code>pkg</code>。</p>
<pre><code class="language-shell">$ tree -L 1
.
├── bin
├── pkg
└── src
</code></pre>
<p>在老的版本中，<code>Go</code>项目代码需要存放在 <code>src</code>下，不过目前基本上都使用 <code>go mod</code> 进行管理了，就没有这个限制了。</p>
<h3><span id="关于编译">关于编译</span></h3><p>主要是几个基础命令，详细的构建编译参数可以查看官网。</p>
<pre><code class="language-shell"># 构建
go build [-o outFileName]

# 运行 不输出可执行文件
go run main.go

# 安装 会编译并将代码拷贝到 GOPATH/bin
go install 
</code></pre>
<p>因为<code>Go</code>支持跨平台，大部分代码可以交叉编译：</p>
<pre><code class="language-shell">SET CGO_ENABLED=0  //禁用CGO
SET GOOS=Linux     //目标平台是linux
SET GOARCH=amd     //目标处理架构是amd64
</code></pre>
<p>同时可以在代码源文件顶部添加添加相关注释来声明相应文件在什么环境下会被构建，也就是所谓的<strong>编译约束（或者说条件编译）</strong>。</p>
<pre><code class="language-go">// +build &lt;tag&gt;
// 逗号分开多个Tag表示 AND
// 空格分开多个Tag 表示 OR
// !表示Not
</code></pre>
<p>标签支持的内容有大概下面这些：</p>
<ul>
<li>操作系统，可以参考环境变量 <code>GOOS</code>，比如：<code>linux</code>、<code>windows</code>、<code>darwin</code>。</li>
<li>系统架构，可以参考环境变量 <code>GOARCH</code>，比如 <code>arch64</code>、<code>x86</code>。</li>
<li>使用的编译器：<code>gc</code> 或者 <code>gccgo</code>。</li>
<li>是否开启 <code>CGO</code>，<code>cgo</code>。</li>
<li><code>Go</code>版本号，<code>go1.18</code>等。</li>
<li>忽略编译文件：<code>ignore</code>。</li>
<li>其他自定义标签。</li>
</ul>
<p><strong>需要注意：<code>// +build</code> 下一行必须是空行。</strong></p>
<p>示例：</p>
<pre><code class="language-go">// +build linux, arch64, !cgo

// +build linux darwin

// +build amd64

// +build ignore
</code></pre>
<p>同时也可以使用文件后缀的方式来自动选择编译文件：</p>
<pre><code class="language-bash">$filename_$GOOS.go
$filename_$GOARCH.go
$filename_$GOOS_$GOARCH.go
</code></pre>
<p>通过 <code>ldflags</code> 在编译过程中为变量赋值：</p>
<pre><code class="language-shell">go build -ldflags &quot;-w -s -X main.Version=$&#123;VERSION&#125; -X github.com/demo/version.BuildNo=$&#123;BUILD_NO&#125;&quot;
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>-w</code> ：删除 <code>DWARF</code> 信息，编译出来的程序无法使用 <code>gdb</code> 进行调试。</li>
<li><code>-s</code> ：删除符号表，<code>panic</code> 的 <code>stack trace</code> 没有文件名、行号信息，等价于 <code>C/C++</code> 程序被 <code>strip</code>。</li>
<li><code>-X</code>：替换包中的变量的值</li>
</ul>
<blockquote>
<p>可以通过 <code>-w -s</code> 有效减少编译出来的本地程序大小，但是不利于调试和日志追踪。</p>
</blockquote>
<h2><span id="变量基础">变量基础</span></h2><h3><span id="变量">变量</span></h3><p><code>Go</code> 必须先声明变量再使用。声明方式为：</p>
<pre><code class="language-go">var 变量名 变量类型

// 或者是直接通过类型推导
var 变量名 = 值

// 或者短变量声明 但是该声明只能用于函数内部
变量名 := 值
</code></pre>
<p>一些简单示例：</p>
<pre><code class="language-go">var name string
var isClosed bool
var age int

// 批量声明
var (
	sex int
	height float64
)

// 匿名变量 _
// 不占用命名空间，不分配内存，不存在重复声明。多用于占位，表示忽略值。
// 可以使用匿名变量检查接口是否被实现
var _ FileWriter = (*io.Writer)(nil)
</code></pre>
<h3><span id="常量">常量</span></h3><p>常量在程序运行中恒定不变。使用关键字 <code>const</code> 声明。<code>Go</code>中没有类似 <code>C/C++</code> 的 静态变量 <code>static</code>。</p>
<pre><code class="language-go">const (
	HttpStatusOK = 200
	HttpNotFound = 404
)
</code></pre>
<p>同时提供了常量计数器 <code>iota</code>，其常用于枚举的声明。<code>iota</code> **只能在常量表达式中使用，且在 <code>const</code> 关键字出现时被重置为0 **。</p>
<pre><code class="language-go">
// 批量声明常量时某一行未赋值，默认等于上面一行的值
// 但是可以通过 iota 进行迭代
const (  
    Trace = iota // 0  
    Debug        // 1  
    Info         // 2  
    Warn         // 3  
    Error        // 4  
    Panic        // 5  
    Fatal        // 6  
)
</code></pre>
<h3><span id="数据类型">数据类型</span></h3><p>基础数据类型不多说，看表：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint</code></td>
<td align="center">操作系统位数对应 <code>uint</code> 位数</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">操作系统位数对应 <code>int</code> 位数</td>
</tr>
<tr>
<td align="center"><code>uintptr</code></td>
<td align="center">无符号整型，用于存放指针</td>
</tr>
<tr>
<td align="center"><code>float32</code></td>
<td align="center">单精度浮点，最大为 <code>math.MaxFloat32</code></td>
</tr>
<tr>
<td align="center"><code>float64</code></td>
<td align="center">双精度浮点，最大为 <code>math.MaxFloat64</code></td>
</tr>
<tr>
<td align="center"><code>bool</code></td>
<td align="center">只支持 <code>true</code> 或者 <code>false</code></td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">字符串为原生数据类型，不可修改。使用 <code>&quot;&quot;</code> 包裹</td>
</tr>
<tr>
<td align="center"><code>byte</code></td>
<td align="center">即 <code>uint8</code>，代表一个 <code>ASCII</code> 字符</td>
</tr>
<tr>
<td align="center"><code>rune</code></td>
<td align="center">代表一个 <code>utf-8</code> 字符</td>
</tr>
</tbody></table>
<h3><span id="运算符">运算符</span></h3><p>算术运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">注意：<strong><code>Go</code>中 自增(<code>++</code>)和自减(<code>--</code>)不是运算符而是语句。</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>关系运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">相等比较，只能比较同类型数据</td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">逻辑运算符，返回一个 <code>bool</code> 类型数据：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td align="center"><code>||</code></td>
<td align="center">逻辑或</td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="center">逻辑非</td>
</tr>
<tr>
<td align="center">位运算符：对整数在内存中的二进制进行操作。</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与，均一为一</td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="center">按位或，有一为一</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或，不同为一</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">有移</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移，高位丢弃，低位补0</td>
</tr>
<tr>
<td align="center">格式化输出占位符：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%v</code></td>
<td align="center">按原本值输出</td>
</tr>
<tr>
<td align="center"><code>%+v</code></td>
<td align="center"><code>%v</code>基础上按字段值展开</td>
</tr>
<tr>
<td align="center"><code>%#v</code></td>
<td align="center">输出<code>Go</code>语法格式的值</td>
</tr>
<tr>
<td align="center"><code>%T</code></td>
<td align="center">输出<code>Go</code>语法格式的类型和值</td>
</tr>
<tr>
<td align="center"><code>%%</code></td>
<td align="center">输出<code>%</code></td>
</tr>
<tr>
<td align="center"><code>%b</code></td>
<td align="center">整型以二进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%o</code></td>
<td align="center">整型以八进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%d</code></td>
<td align="center">整型以十进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%x</code></td>
<td align="center">整型以十六进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%X</code></td>
<td align="center">整型以十六进制方式、字母大写显示</td>
</tr>
<tr>
<td align="center"><code>%U</code></td>
<td align="center"><code>Unicode</code>字符</td>
</tr>
<tr>
<td align="center"><code>%f</code></td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center"><code>%p</code></td>
<td align="center">指针，以十六进制显示</td>
</tr>
</tbody></table>
<h2><span id="流程控制">流程控制</span></h2><h3><span id="判断">判断</span></h3><p>经典的 <code>if-else</code>结构和 <code>switch-case</code>结构。</p>
<p>对于 <code>if-else</code> 可以在 <code>if</code> 后定义表达式，将判断条件后置到 <code>;</code> 后。</p>
<pre><code class="language-go">if err := recover(); err != nil &#123;
	// TODO 
&#125;
</code></pre>
<p>对于 <code>switch-case</code>解构，稍有不同，<code>Go</code> 中默认执行完对于匹配的 <code>case</code> 后会自动<code>break</code>。如果想执行下一个 <code>case</code> 需要使用 <code>fallthrough</code>。</p>
<pre><code class="language-go">func (l *LogLevel) unmarshalText(text []byte) bool &#123;  
    switch string(text) &#123;  
    case &quot;trace&quot;, &quot;TRACE&quot;:  
       *l = TraceLevel  
    case &quot;debug&quot;, &quot;DEBUG&quot;:  
       *l = DebugLevel  
    case &quot;info&quot;, &quot;INFO&quot;:  
       *l = InfoLevel  
    case &quot;warn&quot;, &quot;WARN&quot;:  
       *l = WarnLevel  
    case &quot;error&quot;, &quot;ERROR&quot;:  
       *l = ErrorLevel  
    case &quot;panic&quot;, &quot;PANIC&quot;:  
       *l = PanicLevel  
    case &quot;fatal&quot;:
	    fallthrough
    case &quot;FATAL&quot;:  
       *l = FatalLevel  
    default:  
       return false  
    &#125;  
    return true  
&#125;
</code></pre>
<h3><span id="循环">循环</span></h3><p><code>Go</code> 只有 <code>for</code>循环一种循环方式。不过可以使用 <code>for-range</code>循环。可以通过 <code>break</code> 跳出当前循环，通过 <code>continue</code> 结束本次循环。</p>
<pre><code class="language-go">for 循环变量; 循环条件; 变量自增 &#123; 
    // 循环体
&#125;
</code></pre>
<p>关于循环 <code>Go</code> 在 <code>1.22</code> 之前有一个小坑。就是 <code>1.22</code> 之前的 <code>range</code> 循环迭代器的变量都是一个变量，而不是每次创建新变量，虽然提高了效率但是可能存在一些隐患：</p>
<pre><code class="language-go">allItem := make([]*Item, 0)
for _, item := range items &#123;
	allItem = append(allItem, &amp;item)
&#125;

// 此时所有存进去的 item 都是同一个。
// 如果在旧版本想要解决 需要进行一次赋值 v:= v 重新创建变量
allItem := make([]*Item, 0)
for _, item := range items &#123;
	 item := item
	allItem = append(allItem, &amp;item)
&#125;
</code></pre>
<p>同时如果在 <code>goroutine</code> 和闭包环境下，还会产生以下问题：</p>
<pre><code class="language-go">values := []int&#123;1, 2, 3, 4, 5&#125;

for _, val := range values &#123;
	go func() &#123;
		fmt.Printf(&quot;%d &quot;, val)
	&#125;()
&#125;

time.Sleep(time.Second * 3)

// 此时输出会混乱，因为本质上 闭包的 val 都是同一个。
// 可能的输出:
// 5 5 5 5 5
// 所以在旧版本想要修改 需要将循环变量传参进去
values := []int&#123;1, 2, 3, 4, 5&#125;  
for _, val := range values &#123;  
    go func(val int) &#123;  
       fmt.Printf(&quot;%d &quot;, val)  
    &#125;(val)  
&#125;

time.Sleep(time.Second * 3)

// 闭包的情况
var prints []func()  
for _, v := range []int&#123;1, 2, 3&#125; &#123;  
    prints = append(prints, func() &#123; fmt.Println(v) &#125;)  
&#125;
for _, print := range prints &#123;  
    print()  
&#125;
// 输出
// 3 3 3
// 本质上 v 是同一个
</code></pre>
<p>在 <code>go1.21</code> 可以开启 <code>GOEXPERIMENT=loopvar</code> 构建程序，这样会在循环时默认创建新的变量，在 <code>go1.22</code> 以后，默认使用新的循环语义，就没有这个问题了。</p>
<p>同时在 <code>1.22</code> 版本起，<code>range</code> 可以支持对整数类型循环了。</p>
<pre><code class="language-go">for i := range 10 &#123;
	fmt.Println(i)
&#125;
</code></pre>
<h2><span id="复合数据类型">复合数据类型</span></h2><h3><span id="array-数组">Array 数组</span></h3><p>数组是同种数据类型的集合，<strong>数组长度声明时就确定，大小不可变</strong>。</p>
<pre><code class="language-go">var a [6] int
// 数组必须执行元素类型和 容量
// 数组场合都时类型的一部分

// 定义时初始化
var res [2]bool&#123;false, ture&#125;

// 自动根据初始值判断长度
var arr = [...]&#123;1,2,3,4&#125;

// 根据索引初始化 同时自动判断长度
var result = [...]&#123;1:2, 4&#125;

// 定义多维数组
var position = [3][2]int&#123;  
    [2]int&#123;1, 0&#125;,  
    [2]int&#123;1, 1&#125;,  
    [2]int&#123;0, 1&#125;,  
&#125;
</code></pre>
<blockquote>
<p>数组是一个 <strong>值类型</strong>，支持 <code>==</code> 和 <code>!=</code> 运算符，其内存是被初始化过的。</p>
</blockquote>
<h3><span id="slice-切片">Slice 切片</span></h3><p>切片是用于相同类型元素的可变长度序列，支持自动扩容。切片是<strong>引用类型</strong>。</p>
<pre><code class="language-go">// slice 底层结构
type slice struct &#123;  
    array unsafe.Pointer // 数据首地址  
    len   int            // 长度  
    cap   int            // 容量  
&#125;
</code></pre>
<p>切片的常规用法有如下：</p>
<pre><code class="language-go">// 声明
var nums []int // nil

// 创建&amp;初始化
// 通过 func make(t Type, size ...IntegerType) Type 函数初始
// 第二个参数为元素数量
// 第三个参数为底层数组的容量
nums = make([]int, 0, 10)

// 获取容量
capitity := cap(nums)

// 获取长度
length := len(nums)

// 扩容&amp;追加元素到末尾
// 因为其扩容会导致地址变化，需要对切片重新赋值
// func append(slice []T, elements...T) []T
nums = append(nums, 1)

// 切片操作 左闭右开
s1 := nums[:3]
</code></pre>
<p>需要注意：切片是一个引用类型，其指向了一个底层数组，<strong>对于底层数组的修改会改变切片的值</strong>。</p>
<p><img src="slice_01.png" alt="go_slice"></p>
<blockquote>
<p><strong>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断</strong>。</p>
</blockquote>
<p><code>Go1.18</code> 之前扩容以 1024 为临界点，旧容量小于1024时翻倍，大于时循环增加 <code>25%</code> 直到大于期望容量。</p>
<p><code>Go1,18</code>后对于 <code>slice</code>底层的扩容操作可以参考源码 <code>$GOROOT/src/runtime/slice.go</code>：</p>
<pre><code class="language-go">func nextslicecap(newLen, oldCap int) int &#123;  
    newcap := oldCap  
    doublecap := newcap + newcap  
    if newLen &gt; doublecap &#123;  
       return newLen  
    &#125;  
  
    const threshold = 256  
    if oldCap &lt; threshold &#123;  
       return doublecap  
    &#125;  
    for &#123;  
       // Transition from growing 2x for small slices  
       // to growing 1.25x for large slices. This formula       // gives a smooth-ish transition between the two.       
       newcap += (newcap + 3*threshold) &gt;&gt; 2  
  
       // We need to check `newcap &gt;= newLen` and whether `newcap` overflowed.  
       // newLen is guaranteed to be larger than zero, hence       // when newcap overflows then `uint(newcap) &gt; uint(newLen)`.       // This allows to check for both with the same comparison.       if uint(newcap) &gt;= uint(newLen) &#123;  
          break  
       &#125;  
    &#125;  
  
    // Set newcap to the requested cap when  
    // the newcap calculation overflowed.    if newcap &lt;= 0 &#123;  
       return newLen  
    &#125;  
    return newcap  
&#125;
</code></pre>
<p>新版本不再设立临界值，而是设置了一个值为256的<code>threshold</code>。超过256时不再是循环增长 <code>1/4</code>，而是每次增加 <code>(旧容量+3*256)/4</code>。也就是说，其优化了扩容策略，让底层数组大小的增长变得更加平滑，不会再出现系数从 2到 <code>1.25</code> 的突变。</p>
<table>
<thead>
<tr>
<th align="center"><code>oldCap</code></th>
<th align="center">扩容系数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">256</td>
<td align="center">2.0</td>
</tr>
<tr>
<td align="center">512</td>
<td align="center">1.63</td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">1.44</td>
</tr>
<tr>
<td align="center">2048</td>
<td align="center">1.35</td>
</tr>
<tr>
<td align="center">4096</td>
<td align="center">1.30</td>
</tr>
</tbody></table>
<p>求极限扩容系数最后会趋于 <code>1.25</code>。</p>
<p>这么设计的有点是：提高小切片的增长速度，减少内存分配次数，让大切片增长率减小，节省内存。释放的内存更容易被利用。</p>
<p><code>go</code>可以通过 <code>copy</code> 函数来实现对切片的拷贝。但是需要注意，<strong>目标切片必须是要已经初始化内存空间</strong>的。</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
a2 := a1 //赋值  
  
var a3 []int //这样的切片定义是没有初始化内存空间的  
copy(a3, a1)  
  
var a4 = make([]int, len(a1), cap(a1))  
copy(a4, a1)  
  
fmt.Println(a1, a2, a3, a4) //[1 2 3 4 5] [1 2 3 4 5] [] [1 2 3 4 5]
</code></pre>
<p>如果想要实现删除之类的操作，再<code>go1.21</code>版本之前，可以通过下面的方式进行删除：</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
  
a3 := append(a1[:1], a1[2:]...) //删除切片中索引为1的元素  
fmt.Println(a1, a3)             //[1 3 4 5],但是底层数组的内容是[1 3 4 5 5]
</code></pre>
<p>但是如果是<code>go1.21</code> 以后，其新增了一个泛型包 <code>slices</code>。其提供了一组相关接口，如 比较、元素查找、修改、克隆等。但是其中的删除操作性能较差，如果需要广泛进行删除，可以考虑使用其他的数据结构。</p>
<h3><span id="map-字典">Map 字典</span></h3><p><code>Go</code> 中的 <code>map</code> 的 <code>key</code> 值必须是 <strong>唯一且无序的</strong>。并且其不能是引用类型或者具有引用语义的数据。</p>
<pre><code class="language-go">// 声明
// var m map[keyType]valueType
var set map[int]struct&#123;&#125; // 此时并未分配内存

// 可以通过 make 进行初始化和初始容量的分配
set = make(map[int]struct&#123;&#125;, 10)
set[1] = struct&#123;&#125;&#123;&#125;

// 获取 map 值时可以获取两个数据
// 第二个值表示是否获取到 其是可选的
val, ok := set[1];

// 如果需要删除一个键值对 可以使用 delete()
// 第二个参数为一个 key 值
delete(set, 10)
</code></pre>
<p>同样的，在 <code>go1.21</code> 也引入了 <code>maps</code> 泛型包提供了一组对 <code>map</code> 的操作集合，比如 克隆、拷贝、比较、删除等等。</p>
<p>同时在 <code>go1.24</code> 之前的版本中，<code>go</code> 对于 <code>map</code> 的底层实现是基于 <code>hash table</code>，同时使用拉链法来处理哈希冲突。</p>
<pre><code class="language-go">// runtime/map.go  
// A header for a Go map.  
type hmap struct &#123;  
    count     int // 当前哈希表中的元素数量  
    flags     uint8  
    B         uint8  // 当前哈希表持有的 buckets 数量, 因为哈希表中桶的数量都按2倍扩容,改字段存储对数，也就是 len(buckets) == 2^B    noverflow uint16 // 溢出桶的大致数量  
    hash0     uint32 // hash seed  
  
    buckets    unsafe.Pointer // 存储 2^B 个桶的数组  
    oldbuckets unsafe.Pointer // 扩容时用于保存之前 buckets 的字段 , 大小事buckets的一般  
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)  
    extra *mapextra // optional fields  
&#125;  
  
// mapextra 主要维护，当hmap中的buckets中有一些桶发生溢出，但有达不到扩容阈值时，存储溢出的桶  
type mapextra struct &#123;  
    overflow    *[]*bmap  
    oldoverflow *[]*bmap  
  
    // nextOverflow holds a pointer to a free overflow bucket.    nextOverflow *bmap  
&#125;
</code></pre>
<p>其在<code>map</code>元素达到阈值时会进行扩容操作，主要时两个条件：</p>
<ul>
<li>装载因子（元素数量&#x2F;桶数量）超过阈值</li>
<li>使用了太多的溢出桶</li>
</ul>
<p>并且其扩容流程大概为：</p>
<ol>
<li>新桶数组：分配通常为原先2倍的更大的桶数组，便于分散键值对，减少哈希冲突</li>
<li>重新哈希：遍历旧的桶数组的所有键值对，重新计算哈希并插入到新桶数组</li>
<li>逐步迁移：避免扩容时性能和效率问题，迁移可能时逐步的，扩容期间新、旧桶数组会同时存在，新插入的键值对直接插入新桶数组，对旧桶数组的数据的迁移会在访问时触发</li>
<li>更新状态：所有数组完成迁移会更新内部状态以反映新的结构</li>
</ol>
<p>但是在 <code>go1.24</code>版本后，<code>map</code>的底层实现有优化，从 <code>hash table</code> 变成了 <code>Swiss table</code>。</p>
<p>对于 <code>SwissTable</code>的一些更详细的数据结构的解释可以参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">SwissTable</a></p>
<p><code>SwissTable</code> 基于改进的线性探测法的哈希表实现，通过改进哈希表结构和元数据存储，优化了性能和内存使用。</p>
<p>参考源码：<a target="_blank" rel="noopener" href="https://github.com/dolthub/swiss">SwissGo</a> 或者是 <code>go1.24</code>后版本 <code>runtime\maps\map.go</code>。</p>
<blockquote>
<p>如果想使用原来的 <code>map</code> 可以使用 <code>GOEXPERIMENT=noswissmap</code></p>
</blockquote>
<p>部分源码如下：</p>
<pre><code class="language-go">// swiss map
type Map struct &#123;
    // 填充槽的数量（即所有表中元素的数量） 不包括已删除的槽位
    // 必须是第一个（由编译器知道，对于len()内置）
    used uint64
    // 哈希种子
    seed uintptr
    // 指向一个table指针数组 dirPtr *[dirLen]*table
    // 长度 dirLen 是 1 左移 globalDepth
    // 对 小map的优化: 如果map始终包含 abi.SwissMapGroupSlots 或者更少条目
    // dirPtr 直接指向一个组 dirPtr *group
    // 这种情况下 dirLen = 0
    //used 计算组中已使用的槽位数量(小map永远没有已删除槽位,因为没有需要维护的探测序列)
    dirPtr unsafe.Pointer
    dirLen int
    // 在表目录查找中使用的位数
    globalDepth uint8
    //在目录查找时要从哈希中移出的位数
    //在64位系统上，这是64- globalDepth
    globalShift uint8
    // writing是在写入映射时被切换（异或1）的标志
    // 通常在写入时将其设置为1，但如果有多个并发写入器，那么切换会增加双方都检测到竞争的概率
    writing uint8
    // clearSeq是调用Clear的序列计数器。它用于在迭代期间检测映射清除
    clearSeq uint64
&#125;
</code></pre>
<p>他的扩容采用了扩展哈希(<code>Extendible Hashing</code>)，通过多级目录和表拆分，将扩容开销分摊到多次操作中。</p>
<p>即当 单个表容量达到 <code>maxTableCapacity(默认1024)</code>时触发动态扩容。</p>
<ol>
<li>拆分时会创建两个子表(<code>table left</code>和 <code>table right</code>)，其深度<code>localDepth</code>比原表大1，表示其哈希掩码多使用了一个高位比特</li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1043
func (t *table) split(typ *abi.SwissMapType, m *Map) &#123;
    localDepth := t.localDepth
    localDepth++ // 子表的 localDepth 比原表大 1
    left := newTable(typ, maxTableCapacity, -1, localDepth)
    right := newTable(typ, maxTableCapacity, -1, localDepth)
    // ...
&#125;
</code></pre>
<ol start="2">
<li>根据哈希的高位比特将原表的数据分配到左表和右表。会计算一个掩码，掩码的生成依赖于 <code>localDepth</code></li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1052
mask := localDepthMask(localDepth) // 生成掩码，例如 0x80000000（第 32 位）
for ... &#123;
    hash := typ.Hasher(key, m.seed)
    if hash &amp; mask == 0 &#123;
        left.uncheckedPutSlot(...) // 分配到左表
    &#125; else &#123;
        right.uncheckedPutSlot(...) // 分配到右表
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>完成拆分后更新全局目录 ，使原表的索引范围指向新的子表，如果原表的 <code>localDepth</code> 等于全局的 <code>localDepth</code> 则目录需要翻倍。</li>
</ol>
<pre><code class="language-go">// map.go
func (m *Map) installTableSplit(old, left, right *table) &#123;
    if old.localDepth == m.globalDepth &#123;
        // 目录扩展：大小翻倍
        newDir := make([]*table, m.dirLen*2)
        // 复制旧目录项并指向新表
        for i := range m.dirLen &#123;
            newDir[2*i] = left
            newDir[2*i+1] = right
        &#125;
        m.dirPtr = unsafe.Pointer(&amp;newDir[0])
        m.globalDepth++
    &#125; else &#123;
        // 不扩展目录，仅替换部分项
        entries := 1 &lt;&lt; (m.globalDepth - left.localDepth)
        for i := 0; i &lt; entries; i++ &#123;
            m.directorySet(uintptr(old.index+i), left)
            m.directorySet(uintptr(old.index+i+entries), right)
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>虽然新结构大部分情况下提高了性能，但是部分情况下可能降低，比如 <code>map[key]struct&#123;&#125;</code></p>
</blockquote>
<h3><span id="pointer-指针">Pointer 指针</span></h3><p><code>Go</code>中保留了指针概念，但是对指针的操作进行了限制。常规的指针用法只有：</p>
<ul>
<li><code>&amp;</code> 取地址</li>
<li><code>*</code> 寻址(解引用)</li>
</ul>
<p>大部分情况下的使用跟 <code>C</code> 是类似的。如果要分配内存可以使用 <code>new</code> 为指针申请内存，对于一些特殊的结构 <code>slice、map、channel</code> 可以使用 <code>make</code> 赋初值进行初始化。</p>
<p>但是和<code>C/C++</code>不同，其返回一个局部变量的地址是安全的（存在引用计数）。</p>
<pre><code class="language-go">var a *int // nil 
var b new(int) // int 类型默认值

*b = 100

// 返回局部变量指针
func newInt() *int &#123;
	a := 3
	return &amp;a
&#125;
</code></pre>
<blockquote>
<p>需要注意，对空指针操作会引起 恐慌 <code>Panic</code></p>
</blockquote>
<p><code>Go</code>中对指针的限制在于：</p>
<ul>
<li>不支持算术运算 (<code>p++</code>操作时不合法的，但是 <code>*p++</code> 可以编译通过，视为 <code>(*p)++</code>)</li>
<li>不支持随意转为另一个指针类型，即其<strong>底层类型</strong>必须一致(自定义类型底层类型相同时可以隐式转换)。</li>
<li>不能和其他任意指针类型的值进行比较，只能在指针类型相同或者时可以被隐式转换时，或者和空指针 <code>nil</code> 进行比较时才支持比较操作。</li>
</ul>
<p>但是这些限制并不是绝对的，可以通过 <code>unsafe.Pointer</code> 机制打破这些限制。<code>unsafe.Pointer</code> 类似于 <code>C/C++</code> 的 <code>void*</code>，其同样使用 <code>nil</code> 表示零值声明。</p>
<p>同时 <code>unsafe.Pointer</code> 的滥用可能导致其值的生命周期被修改导致内存泄漏，并且由于 <code>gc</code> 时间的不确定性，应该慎用。</p>
<blockquote>
<p><code>unsafe</code> 包不被保证版本兼容性</p>
</blockquote>
<h3><span id="function-函数">Function 函数</span></h3><p>函数声明使用 <code>func</code> 关键字，函数名为一个标识符，而后时形参表和返回值列表。<br>如果需要调用某函数，使用函数名加上<code>()</code>。</p>
<p><code>Go</code>函数支持变长参数，但是变长参数只能放到参数表的最后，在函数体内，变长参数被视为一个切片。同时，函数参数不支持设置默认值，所有参数都要求被显示传递。</p>
<p>示例：</p>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
)  
  
func Sum(x int, y int) (ret int) &#123;  
    ret = x + y  
    return ret  
    //使用命名返回值return后可以为空  
&#125;  
  
// Println 可变长参数  
// 可变长参数必须放在函数的最后  
func Println(s string, x ...int) &#123;  
    fmt.Println(s, x) //name [1 2 2 3 5]  
    //x是对应类型的切片  
&#125;  
  
// 命名函数中不能声明命名函数  
func main() &#123;  
    ret := Sum(1, 2)  
    fmt.Println(ret)  
  
    Println(&quot;name&quot;, 1, 2, 2, 3, 5)  
&#125;
</code></pre>
<blockquote>
<p>注意：所有的函数传参都是值传递</p>
</blockquote>
<p>在函数内部不能声明命名函数，只能定义<strong>匿名函数</strong>，其定义不包括函数名称部分，其他没有太大区别。同时，匿名函数的形参会遮挡外部环境的变量。</p>
<p>同时，也引出闭包概念：<strong>即一个函数对象，它能够访问并操作其定义时所在作用域中的变量，即使这个函数在其定义的作用域之外被调用</strong>。</p>
<pre><code class="language-go">// 外部函数，返回一个闭包  
func createCounter() func() int &#123;  
    count := 0 // 外部函数的变量  
  
    // 内部函数，闭包  
    return func() int &#123;  
       count++ // 修改外部函数的变量  
       return count  
    &#125;  
&#125;
</code></pre>
<p>其的特点是：</p>
<ul>
<li>访问外部作用域的变量</li>
<li>保持变量状态</li>
<li>本质上是一个函数对象</li>
</ul>
<p>可以借助闭包来隐藏一些内部实现的细节，但是滥用可能会导致内存泄漏问题。</p>
<p>相对特殊的，<code>Go</code>的函数调用存在一个退出阶段：即函数调用返回后，此调用可能并未立即退出。这个阶段的意义主要在于<strong>延迟函数 <code>defer</code></strong>。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func main() &#123;  
    defer fmt.Println(&quot;The third line.&quot;)  
  
    defer fmt.Println(&quot;The second line.&quot;)  
  
    fmt.Println(&quot;The first line.&quot;)  
&#125;

//The first line.  
//The second line.  
//The third line.

// 可以通过延迟操作修改最内侧函数的返回值
func Triple(n int) (r int) &#123;  
    defer func() &#123;  
       r += n // 修改返回值  
    &#125;()  
    return n + n // &lt;=&gt; r = n + n; return  
&#125;
</code></pre>
<p>也就是说：<code>go</code>的 <code>return</code> 操作并不是原子操作，而是：返回值赋值 <code>-&gt;</code> <code>defer</code> 执行 <code>-&gt;</code> 真正返回 的流程。</p>
<p>延迟函数的主要应用场景在于对一些资源的释放，比如对于网络资源的释放、锁的释放等。同时，配合内建函数 <code>panic</code> 和 <code>recover</code> 可以实现类似 <code>try-catch</code> 的效果。</p>
<p>如果函数内注册了多个 <code>defer</code>函数，最终结果会按照注册顺序逆序执行。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func A() &#123;  
    fmt.Println(&quot;A&quot;)  
&#125;  
  
func B() &#123;  
    //defer用来执行释放连接  
    defer func() &#123;  
       err := recover()  
       //recover会尝试恢复panic之前的操作并向后执行  
       fmt.Println(err)  
       fmt.Println(&quot;释放连接。。&quot;)  
    &#125;()  
    panic(&quot;ERROR!!&quot;) //程序崩溃退出  
    fmt.Println(&quot;B&quot;)  
&#125;  
  
func C() &#123;  
    fmt.Println(&quot;C&quot;)  
&#125;  
  
func main() &#123;  
    A()  
    B()  
    C()  
    //A  
    //ERROR!!    //释放连接。。  
    //C  
&#125;
</code></pre>
<p><code>panic</code>：提供的一种报告致命错误的方式，<code>panic</code> 发生时会中断程序运行。</p>
<p><code>recover</code>：拦截运行时 <code>panic</code>，重新获取流程控制权，并返回 <code>panic value</code>。未发生<code>panic</code>会返回 <code>nil</code>。</p>
<blockquote>
<p>注意， <code>recover</code>必须搭配 <code>defer</code> 使用。<code>defer</code> 必须在可能 <code>panic</code> 之前定义，<code>recover</code> 才能拦截到。</p>
</blockquote>
<h3><span id="struct-结构体">Struct 结构体</span></h3><p><code>Go</code> 可以使用 <code>type</code> 关键字声明类型别名或者自定义类型。</p>
<pre><code class="language-go">type LogLevel int

type MyInt int64
</code></pre>
<p>结构体是一种自定义类型，由<code>type</code>和 <code>struct</code> 关键字和 一对 <code>&#123;&#125;</code> 包含一组结构体成员构成（可以不使用 <code>type</code> 关键字声明无名结构体）。</p>
<p>同时需要注意，<code>Go</code> 未设置 <code>public</code>、<code>private</code> 类似的访问修饰符，所以采用了根据首字母大小写区分内部字段释放导出（首字母大写为导出，否则仅包内部可见，函数同样如此）。</p>
<pre><code class="language-go">struct &#123;
	want: 0,
	got: 1,
	args: []
&#125;

type Logger &#123;
	io.Writer
	Filename string
&#125;
</code></pre>
<p>对于<code>Go</code>来说，结构体的尺寸为它所有字段的尺寸加上可能的填充的字节数（通常编译器会在结构体值的两个相邻字段直接填充一些字节来保证一些字段的地址总是某个整数的倍数）。</p>
<blockquote>
<p>特殊的：空结构体的尺寸为零。</p>
</blockquote>
<p>同时每个结构体可以被指定一个标签 <code>tag</code>。语法上来说，这个标签可以是任意的，默认为空字符串，实践过程中其应该被表示为一个 <strong>空格分隔的键值对</strong>形式。</p>
<pre><code class="language-go">type LogOptions struct &#123;  
    // 输出日志等级  
    Level LogLevel `json:&quot;level&quot;`  
    // 日期输出格式  
    Layout string `json:&quot;layout&quot;`  
  
    // 文本格式输出前缀  
    TextPrefix string `json:&quot;text_prefix&quot;`  
    // 日志输出格式标志  
    TextFlag LTextFlag `json:&quot;text_flag&quot;`  

    // Json格式一些默认字段的key  
    TimeEncodeKey    string `json:&quot;time_encode_key&quot;`  
    SourceEncodeKey  string `json:&quot;source_encode_key&quot;`  
    LevelEncodeKey   string `json:&quot;level_encode_key&quot;`  
    MessageEncodeKey string `json:&quot;message_encode_key&quot;`  
    FieldEncodeKey   string `json:&quot;field_encode_key&quot;`  
&#125;
</code></pre>
<p>这些 <code>tag</code> 在相关的序列化和反序列化中常用，比如 <code>json</code> 、<code>xml</code>。如果想要获取这些 <code>tag</code> 的值可以 通过反射。</p>
<blockquote>
<p><code>Go</code> 不存在 <code>Union</code> 联合体</p>
</blockquote>
<h3><span id="channel-通道">Channel 通道</span></h3><h2><span id="面向对象">面向对象</span></h2><h3><span id="方法amp接收者">方法&amp;接收者</span></h3><h3><span id="接口-interface">接口 <code>Interface</code></span></h3><h2><span id="包管理器">包管理器</span></h2><h2><span id="异步编程">异步编程</span></h2><h2><span id="工具-tools">工具 <code>Tools</code></span></h2>
    </div>
    
    
    
    
    
    
    <div id="comment">
        <div id="twikoo-container"></div>
    </div>
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 pengqq&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;pengqq
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
    <div>
        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
        <script>
            var now = new Date(); 
            function createtime() { 
                var grt= new Date("03/10/2025 00:00:00");//在此处修改你的建站时间
                now.setTime(now.getTime()+250); 
                days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
            } 
        setInterval("createtime()",250);
        </script>
    </div>
    <div class="busuanzi-count">
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span class="site-uv">
          <i class="fa fa-user"></i>
          总访客 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
          <span class="post-meta-divider"> | </span>
        </span>
        <span class="site-uv">
          <i class="fa fa-eye"></i>
          访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
        </span>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    



<script>
    twikoo.init({
        el: "#twikoo-container",
        envId: "",
        region: "",
        path: location.pathname,
        lang: "",
    })
</script>


    
</body>
</html>