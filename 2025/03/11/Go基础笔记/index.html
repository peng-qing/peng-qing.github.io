
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | pengqq&#39;s blog</title>
    <meta name="author" content="pengqq" />
    <meta name="description" content="写代码好累..." />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>







<script src="https://s4.zstatic.net/ajax/libs/twikoo/1.6.31/twikoo.all.min.js"></script>



<link rel="stylesheet" href="/css/main.css" />

    <script src="/js/anime.min.js"></script>
    <script src="/js/fireworks.js"></script>
    <script src="/js/sakura.js"></script>
    <link rel="stylesheet" href="/css/cursor.css" />
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PENGQQ&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PENGQQ&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/11
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="golang基础笔记">Golang基础笔记</span></h1><span id="more"></span>

<p>[TOC]</p>
<!-- toc -->

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a><ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85">环境安装</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91">关于编译</a></li>
</ul>
</li>
<li><a href="#%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80">变量基础</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a><ul>
<li><a href="#%E5%88%A4%E6%96%AD">判断</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a></li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">复合数据类型</a><ul>
<li><a href="#array-%E6%95%B0%E7%BB%84">Array 数组</a></li>
<li><a href="#slice-%E5%88%87%E7%89%87">Slice 切片</a></li>
<li><a href="#map-%E5%AD%97%E5%85%B8">Map 字典</a></li>
<li><a href="#pointer-%E6%8C%87%E9%92%88">Pointer 指针</a></li>
<li><a href="#function-%E5%87%BD%E6%95%B0">Function 函数</a></li>
<li><a href="#struct-%E7%BB%93%E6%9E%84%E4%BD%93">Struct 结构体</a></li>
<li><a href="#channel-%E9%80%9A%E9%81%93">Channel 通道</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95method%E6%8E%A5%E6%94%B6%E8%80%85receiver">方法<code>Method</code>&amp;接收者<code>Receiver</code></a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3-interface">接口 <code>Interface</code></a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%85%B7%E9%93%BE">工具链</a><ul>
<li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86">包管理</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a><ul>
<li><a href="#%E5%8D%8F%E7%A8%8B">协程</a></li>
<li><a href="#%E9%94%81-mutex">锁 <code>Mutex</code></a></li>
<li><a href="#%E7%AD%89%E5%BE%85%E7%BB%84-waitgroup">等待组 <code>WaitGroup</code></a></li>
<li><a href="#%E5%A4%9A%E5%8D%8F%E7%A8%8B%E9%97%B4%E9%80%9A%E7%9F%A5-cond">多协程间通知 <code>Cond</code></a></li>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic">原子操作 Atomic</a></li>
<li><a href="#gmp%E6%A8%A1%E5%9E%8B"><code>GMP</code>模型</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cgc">内存模型和GC</a><ul>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></li>
<li><a href="#gc-%E7%AE%97%E6%B3%95">GC 算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="开发环境">开发环境</span></h2><h3><span id="环境安装">环境安装</span></h3><p><code>Linux</code>安装：</p>
<pre><code class="language-shell">
# 下载指定版本
wget https://golang.google.cn/dl/go1.21.1.linux-amd64.tar.gz

# 解压到指定目录
tar -C /usr/local/ -zxvf go1.21.1.linux-amd64.tar.gz

# 配置环境变量 ~/.bashrc or ~/.profile 添加
export GOROOT=/usr/local/go/bin
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT

# 重新加载配置
source .profile

# 验证
go version
</code></pre>
<p>如果是 <code>Windows</code> 下载安装然后同理配置相关的环境变量即可。</p>
<p>需要注意的是，可以在 <code>GOPATH</code> 目录下新建三个目录 <code>bin</code> 、<code>src</code>、<code>pkg</code>。</p>
<pre><code class="language-shell">$ tree -L 1
.
├── bin
├── pkg
└── src
</code></pre>
<p>在老的版本中，<code>Go</code>项目代码需要存放在 <code>src</code>下，不过目前基本上都使用 <code>go mod</code> 进行管理了，就没有这个限制了。</p>
<h3><span id="关于编译">关于编译</span></h3><p>主要是几个基础命令，详细的构建编译参数可以查看官网。</p>
<pre><code class="language-shell"># 构建
go build [-o outFileName]

# 运行 不输出可执行文件
go run main.go

# 安装 会编译并将代码拷贝到 GOPATH/bin
go install 
</code></pre>
<p>因为<code>Go</code>支持跨平台，大部分代码可以交叉编译：</p>
<pre><code class="language-shell">SET CGO_ENABLED=0  //禁用CGO
SET GOOS=Linux     //目标平台是linux
SET GOARCH=amd     //目标处理架构是amd64
</code></pre>
<p>同时可以在代码源文件顶部添加添加相关注释来声明相应文件在什么环境下会被构建，也就是所谓的<strong>编译约束（或者说条件编译）</strong>。</p>
<pre><code class="language-go">// +build &lt;tag&gt;
// 逗号分开多个Tag表示 AND
// 空格分开多个Tag 表示 OR
// !表示Not
</code></pre>
<p>标签支持的内容有大概下面这些：</p>
<ul>
<li>操作系统，可以参考环境变量 <code>GOOS</code>，比如：<code>linux</code>、<code>windows</code>、<code>darwin</code>。</li>
<li>系统架构，可以参考环境变量 <code>GOARCH</code>，比如 <code>arch64</code>、<code>x86</code>。</li>
<li>使用的编译器：<code>gc</code> 或者 <code>gccgo</code>。</li>
<li>是否开启 <code>CGO</code>，<code>cgo</code>。</li>
<li><code>Go</code>版本号，<code>go1.18</code>等。</li>
<li>忽略编译文件：<code>ignore</code>。</li>
<li>其他自定义标签。</li>
</ul>
<p><strong>需要注意：<code>// +build</code> 下一行必须是空行。</strong></p>
<p>示例：</p>
<pre><code class="language-go">// +build linux, arch64, !cgo

// +build linux darwin

// +build amd64

// +build ignore
</code></pre>
<p>同时也可以使用文件后缀的方式来自动选择编译文件：</p>
<pre><code class="language-bash">$filename_$GOOS.go
$filename_$GOARCH.go
$filename_$GOOS_$GOARCH.go
</code></pre>
<p>通过 <code>ldflags</code> 在编译过程中为变量赋值：</p>
<pre><code class="language-shell">go build -ldflags &quot;-w -s -X main.Version=$&#123;VERSION&#125; -X github.com/demo/version.BuildNo=$&#123;BUILD_NO&#125;&quot;
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>-w</code> ：删除 <code>DWARF</code> 信息，编译出来的程序无法使用 <code>gdb</code> 进行调试。</li>
<li><code>-s</code> ：删除符号表，<code>panic</code> 的 <code>stack trace</code> 没有文件名、行号信息，等价于 <code>C/C++</code> 程序被 <code>strip</code>。</li>
<li><code>-X</code>：替换包中的变量的值</li>
</ul>
<blockquote>
<p>可以通过 <code>-w -s</code> 有效减少编译出来的本地程序大小，但是不利于调试和日志追踪。</p>
</blockquote>
<h2><span id="变量基础">变量基础</span></h2><h3><span id="变量">变量</span></h3><p><code>Go</code> 必须先声明变量再使用。声明方式为：</p>
<pre><code class="language-go">var 变量名 变量类型

// 或者是直接通过类型推导
var 变量名 = 值

// 或者短变量声明 但是该声明只能用于函数内部
变量名 := 值
</code></pre>
<p>一些简单示例：</p>
<pre><code class="language-go">var name string
var isClosed bool
var age int

// 批量声明
var (
	sex int
	height float64
)

// 匿名变量 _
// 不占用命名空间，不分配内存，不存在重复声明。多用于占位，表示忽略值。
// 可以使用匿名变量检查接口是否被实现
var _ FileWriter = (*io.Writer)(nil)
</code></pre>
<h3><span id="常量">常量</span></h3><p>常量在程序运行中恒定不变。使用关键字 <code>const</code> 声明。<code>Go</code>中没有类似 <code>C/C++</code> 的 静态变量 <code>static</code>。</p>
<pre><code class="language-go">const (
	HttpStatusOK = 200
	HttpNotFound = 404
)
</code></pre>
<p>同时提供了常量计数器 <code>iota</code>，其常用于枚举的声明。<code>iota</code> **只能在常量表达式中使用，且在 <code>const</code> 关键字出现时被重置为0 **。</p>
<pre><code class="language-go">
// 批量声明常量时某一行未赋值，默认等于上面一行的值
// 但是可以通过 iota 进行迭代
const (  
    Trace = iota // 0  
    Debug        // 1  
    Info         // 2  
    Warn         // 3  
    Error        // 4  
    Panic        // 5  
    Fatal        // 6  
)
</code></pre>
<h3><span id="数据类型">数据类型</span></h3><p>基础数据类型不多说，看表：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint</code></td>
<td align="center">操作系统位数对应 <code>uint</code> 位数</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">操作系统位数对应 <code>int</code> 位数</td>
</tr>
<tr>
<td align="center"><code>uintptr</code></td>
<td align="center">无符号整型，用于存放指针</td>
</tr>
<tr>
<td align="center"><code>float32</code></td>
<td align="center">单精度浮点，最大为 <code>math.MaxFloat32</code></td>
</tr>
<tr>
<td align="center"><code>float64</code></td>
<td align="center">双精度浮点，最大为 <code>math.MaxFloat64</code></td>
</tr>
<tr>
<td align="center"><code>bool</code></td>
<td align="center">只支持 <code>true</code> 或者 <code>false</code></td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">字符串为原生数据类型，不可修改。使用 <code>&quot;&quot;</code> 包裹</td>
</tr>
<tr>
<td align="center"><code>byte</code></td>
<td align="center">即 <code>uint8</code>，代表一个 <code>ASCII</code> 字符</td>
</tr>
<tr>
<td align="center"><code>rune</code></td>
<td align="center">代表一个 <code>utf-8</code> 字符</td>
</tr>
</tbody></table>
<h3><span id="运算符">运算符</span></h3><p>算术运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">注意：<strong><code>Go</code>中 自增(<code>++</code>)和自减(<code>--</code>)不是运算符而是语句。</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>关系运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">相等比较，只能比较同类型数据</td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">逻辑运算符，返回一个 <code>bool</code> 类型数据：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td align="center"><code>||</code></td>
<td align="center">逻辑或</td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="center">逻辑非</td>
</tr>
<tr>
<td align="center">位运算符：对整数在内存中的二进制进行操作。</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与，均一为一</td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="center">按位或，有一为一</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或，不同为一</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">有移</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移，高位丢弃，低位补0</td>
</tr>
<tr>
<td align="center">格式化输出占位符：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%v</code></td>
<td align="center">按原本值输出</td>
</tr>
<tr>
<td align="center"><code>%+v</code></td>
<td align="center"><code>%v</code>基础上按字段值展开</td>
</tr>
<tr>
<td align="center"><code>%#v</code></td>
<td align="center">输出<code>Go</code>语法格式的值</td>
</tr>
<tr>
<td align="center"><code>%T</code></td>
<td align="center">输出<code>Go</code>语法格式的类型和值</td>
</tr>
<tr>
<td align="center"><code>%%</code></td>
<td align="center">输出<code>%</code></td>
</tr>
<tr>
<td align="center"><code>%b</code></td>
<td align="center">整型以二进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%o</code></td>
<td align="center">整型以八进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%d</code></td>
<td align="center">整型以十进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%x</code></td>
<td align="center">整型以十六进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%X</code></td>
<td align="center">整型以十六进制方式、字母大写显示</td>
</tr>
<tr>
<td align="center"><code>%U</code></td>
<td align="center"><code>Unicode</code>字符</td>
</tr>
<tr>
<td align="center"><code>%f</code></td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center"><code>%p</code></td>
<td align="center">指针，以十六进制显示</td>
</tr>
</tbody></table>
<h2><span id="流程控制">流程控制</span></h2><h3><span id="判断">判断</span></h3><p>经典的 <code>if-else</code>结构和 <code>switch-case</code>结构。</p>
<p>对于 <code>if-else</code> 可以在 <code>if</code> 后定义表达式，将判断条件后置到 <code>;</code> 后。</p>
<pre><code class="language-go">if err := recover(); err != nil &#123;
	// TODO 
&#125;
</code></pre>
<p>对于 <code>switch-case</code>解构，稍有不同，<code>Go</code> 中默认执行完对于匹配的 <code>case</code> 后会自动<code>break</code>。如果想执行下一个 <code>case</code> 需要使用 <code>fallthrough</code>。</p>
<pre><code class="language-go">func (l *LogLevel) unmarshalText(text []byte) bool &#123;  
    switch string(text) &#123;  
    case &quot;trace&quot;, &quot;TRACE&quot;:  
       *l = TraceLevel  
    case &quot;debug&quot;, &quot;DEBUG&quot;:  
       *l = DebugLevel  
    case &quot;info&quot;, &quot;INFO&quot;:  
       *l = InfoLevel  
    case &quot;warn&quot;, &quot;WARN&quot;:  
       *l = WarnLevel  
    case &quot;error&quot;, &quot;ERROR&quot;:  
       *l = ErrorLevel  
    case &quot;panic&quot;, &quot;PANIC&quot;:  
       *l = PanicLevel  
    case &quot;fatal&quot;:
	    fallthrough
    case &quot;FATAL&quot;:  
       *l = FatalLevel  
    default:  
       return false  
    &#125;  
    return true  
&#125;
</code></pre>
<h3><span id="循环">循环</span></h3><p><code>Go</code> 只有 <code>for</code>循环一种循环方式。不过可以使用 <code>for-range</code>循环。可以通过 <code>break</code> 跳出当前循环，通过 <code>continue</code> 结束本次循环。</p>
<pre><code class="language-go">for 循环变量; 循环条件; 变量自增 &#123; 
    // 循环体
&#125;
</code></pre>
<p>关于循环 <code>Go</code> 在 <code>1.22</code> 之前有一个小坑。就是 <code>1.22</code> 之前的 <code>range</code> 循环迭代器的变量都是一个变量，而不是每次创建新变量，虽然提高了效率但是可能存在一些隐患：</p>
<pre><code class="language-go">allItem := make([]*Item, 0)
for _, item := range items &#123;
	allItem = append(allItem, &amp;item)
&#125;

// 此时所有存进去的 item 都是同一个。
// 如果在旧版本想要解决 需要进行一次赋值 v:= v 重新创建变量
allItem := make([]*Item, 0)
for _, item := range items &#123;
	 item := item
	allItem = append(allItem, &amp;item)
&#125;
</code></pre>
<p>同时如果在 <code>goroutine</code> 和闭包环境下，还会产生以下问题：</p>
<pre><code class="language-go">values := []int&#123;1, 2, 3, 4, 5&#125;

for _, val := range values &#123;
	go func() &#123;
		fmt.Printf(&quot;%d &quot;, val)
	&#125;()
&#125;

time.Sleep(time.Second * 3)

// 此时输出会混乱，因为本质上 闭包的 val 都是同一个。
// 可能的输出:
// 5 5 5 5 5
// 所以在旧版本想要修改 需要将循环变量传参进去
values := []int&#123;1, 2, 3, 4, 5&#125;  
for _, val := range values &#123;  
    go func(val int) &#123;  
       fmt.Printf(&quot;%d &quot;, val)  
    &#125;(val)  
&#125;

time.Sleep(time.Second * 3)

// 闭包的情况
var prints []func()  
for _, v := range []int&#123;1, 2, 3&#125; &#123;  
    prints = append(prints, func() &#123; fmt.Println(v) &#125;)  
&#125;
for _, print := range prints &#123;  
    print()  
&#125;
// 输出
// 3 3 3
// 本质上 v 是同一个
</code></pre>
<p>在 <code>go1.21</code> 可以开启 <code>GOEXPERIMENT=loopvar</code> 构建程序，这样会在循环时默认创建新的变量，在 <code>go1.22</code> 以后，默认使用新的循环语义，就没有这个问题了。</p>
<p>同时在 <code>1.22</code> 版本起，<code>range</code> 可以支持对整数类型循环了。</p>
<pre><code class="language-go">for i := range 10 &#123;
	fmt.Println(i)
&#125;
</code></pre>
<h2><span id="复合数据类型">复合数据类型</span></h2><h3><span id="array-数组">Array 数组</span></h3><p>数组是同种数据类型的集合，<strong>数组长度声明时就确定，大小不可变</strong>。</p>
<pre><code class="language-go">var a [6] int
// 数组必须执行元素类型和 容量
// 数组场合都时类型的一部分

// 定义时初始化
var res [2]bool&#123;false, ture&#125;

// 自动根据初始值判断长度
var arr = [...]&#123;1,2,3,4&#125;

// 根据索引初始化 同时自动判断长度
var result = [...]&#123;1:2, 4&#125;

// 定义多维数组
var position = [3][2]int&#123;  
    [2]int&#123;1, 0&#125;,  
    [2]int&#123;1, 1&#125;,  
    [2]int&#123;0, 1&#125;,  
&#125;
</code></pre>
<blockquote>
<p>数组是一个 <strong>值类型</strong>，支持 <code>==</code> 和 <code>!=</code> 运算符，其内存是被初始化过的。</p>
</blockquote>
<h3><span id="slice-切片">Slice 切片</span></h3><p>切片是用于相同类型元素的可变长度序列，支持自动扩容。切片是<strong>引用类型</strong>。</p>
<pre><code class="language-go">// slice 底层结构
type slice struct &#123;  
    array unsafe.Pointer // 数据首地址  
    len   int            // 长度  
    cap   int            // 容量  
&#125;
</code></pre>
<p>切片的常规用法有如下：</p>
<pre><code class="language-go">// 声明
var nums []int // nil

// 创建&amp;初始化
// 通过 func make(t Type, size ...IntegerType) Type 函数初始
// 第二个参数为元素数量
// 第三个参数为底层数组的容量
nums = make([]int, 0, 10)

// 获取容量
capitity := cap(nums)

// 获取长度
length := len(nums)

// 扩容&amp;追加元素到末尾
// 因为其扩容会导致地址变化，需要对切片重新赋值
// func append(slice []T, elements...T) []T
nums = append(nums, 1)

// 切片操作 左闭右开
s1 := nums[:3]
</code></pre>
<p>需要注意：切片是一个引用类型，其指向了一个底层数组，<strong>对于底层数组的修改会改变切片的值</strong>。</p>
<p><img src="slice_01.png" alt="go_slice"></p>
<blockquote>
<p><strong>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断</strong>。</p>
</blockquote>
<p><code>Go1.18</code> 之前扩容以 1024 为临界点，旧容量小于1024时翻倍，大于时循环增加 <code>25%</code> 直到大于期望容量。</p>
<p><code>Go1,18</code>后对于 <code>slice</code>底层的扩容操作可以参考源码 <code>$GOROOT/src/runtime/slice.go</code>：</p>
<pre><code class="language-go">func nextslicecap(newLen, oldCap int) int &#123;  
    newcap := oldCap  
    doublecap := newcap + newcap  
    if newLen &gt; doublecap &#123;  
       return newLen  
    &#125;  
  
    const threshold = 256  
    if oldCap &lt; threshold &#123;  
       return doublecap  
    &#125;  
    for &#123;  
       // Transition from growing 2x for small slices  
       // to growing 1.25x for large slices. This formula       // gives a smooth-ish transition between the two.       
       newcap += (newcap + 3*threshold) &gt;&gt; 2  
  
       // We need to check `newcap &gt;= newLen` and whether `newcap` overflowed.  
       // newLen is guaranteed to be larger than zero, hence       // when newcap overflows then `uint(newcap) &gt; uint(newLen)`.       // This allows to check for both with the same comparison.       if uint(newcap) &gt;= uint(newLen) &#123;  
          break  
       &#125;  
    &#125;  
  
    // Set newcap to the requested cap when  
    // the newcap calculation overflowed.    if newcap &lt;= 0 &#123;  
       return newLen  
    &#125;  
    return newcap  
&#125;
</code></pre>
<p>新版本不再设立临界值，而是设置了一个值为256的<code>threshold</code>。超过256时不再是循环增长 <code>1/4</code>，而是每次增加 <code>(旧容量+3*256)/4</code>。也就是说，其优化了扩容策略，让底层数组大小的增长变得更加平滑，不会再出现系数从 2到 <code>1.25</code> 的突变。</p>
<table>
<thead>
<tr>
<th align="center"><code>oldCap</code></th>
<th align="center">扩容系数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">256</td>
<td align="center">2.0</td>
</tr>
<tr>
<td align="center">512</td>
<td align="center">1.63</td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">1.44</td>
</tr>
<tr>
<td align="center">2048</td>
<td align="center">1.35</td>
</tr>
<tr>
<td align="center">4096</td>
<td align="center">1.30</td>
</tr>
</tbody></table>
<p>求极限扩容系数最后会趋于 <code>1.25</code>。</p>
<p>这么设计的有点是：提高小切片的增长速度，减少内存分配次数，让大切片增长率减小，节省内存。释放的内存更容易被利用。</p>
<p><code>go</code>可以通过 <code>copy</code> 函数来实现对切片的拷贝。但是需要注意，<strong>目标切片必须是要已经初始化内存空间</strong>的。</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
a2 := a1 //赋值  
  
var a3 []int //这样的切片定义是没有初始化内存空间的  
copy(a3, a1)  
  
var a4 = make([]int, len(a1), cap(a1))  
copy(a4, a1)  
  
fmt.Println(a1, a2, a3, a4) //[1 2 3 4 5] [1 2 3 4 5] [] [1 2 3 4 5]
</code></pre>
<p>如果想要实现删除之类的操作，再<code>go1.21</code>版本之前，可以通过下面的方式进行删除：</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
  
a3 := append(a1[:1], a1[2:]...) //删除切片中索引为1的元素  
fmt.Println(a1, a3)             //[1 3 4 5],但是底层数组的内容是[1 3 4 5 5]
</code></pre>
<p>但是如果是<code>go1.21</code> 以后，其新增了一个泛型包 <code>slices</code>。其提供了一组相关接口，如 比较、元素查找、修改、克隆等。但是其中的删除操作性能较差，如果需要广泛进行删除，可以考虑使用其他的数据结构。</p>
<h3><span id="map-字典">Map 字典</span></h3><p><code>Go</code> 中的 <code>map</code> 的 <code>key</code> 值必须是 <strong>唯一且无序的</strong>。并且其不能是引用类型或者具有引用语义的数据。</p>
<pre><code class="language-go">// 声明
// var m map[keyType]valueType
var set map[int]struct&#123;&#125; // 此时并未分配内存

// 可以通过 make 进行初始化和初始容量的分配
set = make(map[int]struct&#123;&#125;, 10)
set[1] = struct&#123;&#125;&#123;&#125;

// 获取 map 值时可以获取两个数据
// 第二个值表示是否获取到 其是可选的
val, ok := set[1];

// 如果需要删除一个键值对 可以使用 delete()
// 第二个参数为一个 key 值
delete(set, 10)
</code></pre>
<p>同样的，在 <code>go1.21</code> 也引入了 <code>maps</code> 泛型包提供了一组对 <code>map</code> 的操作集合，比如 克隆、拷贝、比较、删除等等。</p>
<p>同时在 <code>go1.24</code> 之前的版本中，<code>go</code> 对于 <code>map</code> 的底层实现是基于 <code>hash table</code>，同时使用拉链法来处理哈希冲突。</p>
<pre><code class="language-go">// runtime/map.go  
// A header for a Go map.  
type hmap struct &#123;  
    count     int // 当前哈希表中的元素数量  
    flags     uint8  
    B         uint8  // 当前哈希表持有的 buckets 数量, 因为哈希表中桶的数量都按2倍扩容,改字段存储对数，也就是 len(buckets) == 2^B    noverflow uint16 // 溢出桶的大致数量  
    hash0     uint32 // hash seed  
  
    buckets    unsafe.Pointer // 存储 2^B 个桶的数组  
    oldbuckets unsafe.Pointer // 扩容时用于保存之前 buckets 的字段 , 大小事buckets的一般  
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)  
    extra *mapextra // optional fields  
&#125;  
  
// mapextra 主要维护，当hmap中的buckets中有一些桶发生溢出，但有达不到扩容阈值时，存储溢出的桶  
type mapextra struct &#123;  
    overflow    *[]*bmap  
    oldoverflow *[]*bmap  
  
    // nextOverflow holds a pointer to a free overflow bucket.    nextOverflow *bmap  
&#125;
</code></pre>
<p>其在<code>map</code>元素达到阈值时会进行扩容操作，主要时两个条件：</p>
<ul>
<li>装载因子（元素数量&#x2F;桶数量）超过阈值</li>
<li>使用了太多的溢出桶</li>
</ul>
<p>并且其扩容流程大概为：</p>
<ol>
<li>新桶数组：分配通常为原先2倍的更大的桶数组，便于分散键值对，减少哈希冲突</li>
<li>重新哈希：遍历旧的桶数组的所有键值对，重新计算哈希并插入到新桶数组</li>
<li>逐步迁移：避免扩容时性能和效率问题，迁移可能时逐步的，扩容期间新、旧桶数组会同时存在，新插入的键值对直接插入新桶数组，对旧桶数组的数据的迁移会在访问时触发</li>
<li>更新状态：所有数组完成迁移会更新内部状态以反映新的结构</li>
</ol>
<p>但是在 <code>go1.24</code>版本后，<code>map</code>的底层实现有优化，从 <code>hash table</code> 变成了 <code>Swiss table</code>。</p>
<p>对于 <code>SwissTable</code>的一些更详细的数据结构的解释可以参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">SwissTable</a></p>
<p><code>SwissTable</code> 基于改进的线性探测法的哈希表实现，通过改进哈希表结构和元数据存储，优化了性能和内存使用。</p>
<p>参考源码：<a target="_blank" rel="noopener" href="https://github.com/dolthub/swiss">SwissGo</a> 或者是 <code>go1.24</code>后版本 <code>runtime\maps\map.go</code>。</p>
<blockquote>
<p>如果想使用原来的 <code>map</code> 可以使用 <code>GOEXPERIMENT=noswissmap</code></p>
</blockquote>
<p>部分源码如下：</p>
<pre><code class="language-go">// swiss map
type Map struct &#123;
    // 填充槽的数量（即所有表中元素的数量） 不包括已删除的槽位
    // 必须是第一个（由编译器知道，对于len()内置）
    used uint64
    // 哈希种子
    seed uintptr
    // 指向一个table指针数组 dirPtr *[dirLen]*table
    // 长度 dirLen 是 1 左移 globalDepth
    // 对 小map的优化: 如果map始终包含 abi.SwissMapGroupSlots 或者更少条目
    // dirPtr 直接指向一个组 dirPtr *group
    // 这种情况下 dirLen = 0
    //used 计算组中已使用的槽位数量(小map永远没有已删除槽位,因为没有需要维护的探测序列)
    dirPtr unsafe.Pointer
    dirLen int
    // 在表目录查找中使用的位数
    globalDepth uint8
    //在目录查找时要从哈希中移出的位数
    //在64位系统上，这是64- globalDepth
    globalShift uint8
    // writing是在写入映射时被切换（异或1）的标志
    // 通常在写入时将其设置为1，但如果有多个并发写入器，那么切换会增加双方都检测到竞争的概率
    writing uint8
    // clearSeq是调用Clear的序列计数器。它用于在迭代期间检测映射清除
    clearSeq uint64
&#125;
</code></pre>
<p>他的扩容采用了扩展哈希(<code>Extendible Hashing</code>)，通过多级目录和表拆分，将扩容开销分摊到多次操作中。</p>
<p>即当 单个表容量达到 <code>maxTableCapacity(默认1024)</code>时触发动态扩容。</p>
<ol>
<li>拆分时会创建两个子表(<code>table left</code>和 <code>table right</code>)，其深度<code>localDepth</code>比原表大1，表示其哈希掩码多使用了一个高位比特</li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1043
func (t *table) split(typ *abi.SwissMapType, m *Map) &#123;
    localDepth := t.localDepth
    localDepth++ // 子表的 localDepth 比原表大 1
    left := newTable(typ, maxTableCapacity, -1, localDepth)
    right := newTable(typ, maxTableCapacity, -1, localDepth)
    // ...
&#125;
</code></pre>
<ol start="2">
<li>根据哈希的高位比特将原表的数据分配到左表和右表。会计算一个掩码，掩码的生成依赖于 <code>localDepth</code></li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1052
mask := localDepthMask(localDepth) // 生成掩码，例如 0x80000000（第 32 位）
for ... &#123;
    hash := typ.Hasher(key, m.seed)
    if hash &amp; mask == 0 &#123;
        left.uncheckedPutSlot(...) // 分配到左表
    &#125; else &#123;
        right.uncheckedPutSlot(...) // 分配到右表
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>完成拆分后更新全局目录 ，使原表的索引范围指向新的子表，如果原表的 <code>localDepth</code> 等于全局的 <code>localDepth</code> 则目录需要翻倍。</li>
</ol>
<pre><code class="language-go">// map.go
func (m *Map) installTableSplit(old, left, right *table) &#123;
    if old.localDepth == m.globalDepth &#123;
        // 目录扩展：大小翻倍
        newDir := make([]*table, m.dirLen*2)
        // 复制旧目录项并指向新表
        for i := range m.dirLen &#123;
            newDir[2*i] = left
            newDir[2*i+1] = right
        &#125;
        m.dirPtr = unsafe.Pointer(&amp;newDir[0])
        m.globalDepth++
    &#125; else &#123;
        // 不扩展目录，仅替换部分项
        entries := 1 &lt;&lt; (m.globalDepth - left.localDepth)
        for i := 0; i &lt; entries; i++ &#123;
            m.directorySet(uintptr(old.index+i), left)
            m.directorySet(uintptr(old.index+i+entries), right)
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>虽然新结构大部分情况下提高了性能，但是部分情况下可能降低，比如 <code>map[key]struct&#123;&#125;</code></p>
</blockquote>
<h3><span id="pointer-指针">Pointer 指针</span></h3><p><code>Go</code>中保留了指针概念，但是对指针的操作进行了限制。常规的指针用法只有：</p>
<ul>
<li><code>&amp;</code> 取地址</li>
<li><code>*</code> 寻址(解引用)</li>
</ul>
<p>大部分情况下的使用跟 <code>C</code> 是类似的。如果要分配内存可以使用 <code>new</code> 为指针申请内存，对于一些特殊的结构 <code>slice、map、channel</code> 可以使用 <code>make</code> 赋初值进行初始化。</p>
<p>但是和<code>C/C++</code>不同，其返回一个局部变量的地址是安全的（存在引用计数）。</p>
<pre><code class="language-go">var a *int // nil 
var b new(int) // int 类型默认值

*b = 100

// 返回局部变量指针
func newInt() *int &#123;
	a := 3
	return &amp;a
&#125;
</code></pre>
<blockquote>
<p>需要注意，对空指针操作会引起 恐慌 <code>Panic</code></p>
</blockquote>
<p><code>Go</code>中对指针的限制在于：</p>
<ul>
<li>不支持算术运算 (<code>p++</code>操作时不合法的，但是 <code>*p++</code> 可以编译通过，视为 <code>(*p)++</code>)</li>
<li>不支持随意转为另一个指针类型，即其<strong>底层类型</strong>必须一致(自定义类型底层类型相同时可以隐式转换)。</li>
<li>不能和其他任意指针类型的值进行比较，只能在指针类型相同或者时可以被隐式转换时，或者和空指针 <code>nil</code> 进行比较时才支持比较操作。</li>
</ul>
<p>但是这些限制并不是绝对的，可以通过 <code>unsafe.Pointer</code> 机制打破这些限制。<code>unsafe.Pointer</code> 类似于 <code>C/C++</code> 的 <code>void*</code>，其同样使用 <code>nil</code> 表示零值声明。</p>
<p>同时 <code>unsafe.Pointer</code> 的滥用可能导致其值的生命周期被修改导致内存泄漏，并且由于 <code>gc</code> 时间的不确定性，应该慎用。</p>
<blockquote>
<p><code>unsafe</code> 包不被保证版本兼容性</p>
</blockquote>
<h3><span id="function-函数">Function 函数</span></h3><p>函数声明使用 <code>func</code> 关键字，函数名为一个标识符，而后时形参表和返回值列表。<br>如果需要调用某函数，使用函数名加上<code>()</code>。</p>
<p><code>Go</code>函数支持变长参数，但是变长参数只能放到参数表的最后，在函数体内，变长参数被视为一个切片。同时，函数参数不支持设置默认值，所有参数都要求被显示传递。</p>
<p>示例：</p>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
)  
  
func Sum(x int, y int) (ret int) &#123;  
    ret = x + y  
    return ret  
    //使用命名返回值return后可以为空  
&#125;  
  
// Println 可变长参数  
// 可变长参数必须放在函数的最后  
func Println(s string, x ...int) &#123;  
    fmt.Println(s, x) //name [1 2 2 3 5]  
    //x是对应类型的切片  
&#125;  
  
// 命名函数中不能声明命名函数  
func main() &#123;  
    ret := Sum(1, 2)  
    fmt.Println(ret)  
  
    Println(&quot;name&quot;, 1, 2, 2, 3, 5)  
&#125;
</code></pre>
<blockquote>
<p>注意：所有的函数传参都是值传递</p>
</blockquote>
<p>在函数内部不能声明命名函数，只能定义<strong>匿名函数</strong>，其定义不包括函数名称部分，其他没有太大区别。同时，匿名函数的形参会遮挡外部环境的变量。</p>
<p>同时，也引出闭包概念：<strong>即一个函数对象，它能够访问并操作其定义时所在作用域中的变量，即使这个函数在其定义的作用域之外被调用</strong>。</p>
<pre><code class="language-go">// 外部函数，返回一个闭包  
func createCounter() func() int &#123;  
    count := 0 // 外部函数的变量  
  
    // 内部函数，闭包  
    return func() int &#123;  
       count++ // 修改外部函数的变量  
       return count  
    &#125;  
&#125;
</code></pre>
<p>其的特点是：</p>
<ul>
<li>访问外部作用域的变量</li>
<li>保持变量状态</li>
<li>本质上是一个函数对象</li>
</ul>
<p>可以借助闭包来隐藏一些内部实现的细节，但是滥用可能会导致内存泄漏问题。</p>
<p>相对特殊的，<code>Go</code>的函数调用存在一个退出阶段：即函数调用返回后，此调用可能并未立即退出。这个阶段的意义主要在于<strong>延迟函数 <code>defer</code></strong>。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func main() &#123;  
    defer fmt.Println(&quot;The third line.&quot;)  
  
    defer fmt.Println(&quot;The second line.&quot;)  
  
    fmt.Println(&quot;The first line.&quot;)  
&#125;

//The first line.  
//The second line.  
//The third line.

// 可以通过延迟操作修改最内侧函数的返回值
func Triple(n int) (r int) &#123;  
    defer func() &#123;  
       r += n // 修改返回值  
    &#125;()  
    return n + n // &lt;=&gt; r = n + n; return  
&#125;
</code></pre>
<p>也就是说：<code>go</code>的 <code>return</code> 操作并不是原子操作，而是：返回值赋值 <code>-&gt;</code> <code>defer</code> 执行 <code>-&gt;</code> 真正返回 的流程。</p>
<p>延迟函数的主要应用场景在于对一些资源的释放，比如对于网络资源的释放、锁的释放等。同时，配合内建函数 <code>panic</code> 和 <code>recover</code> 可以实现类似 <code>try-catch</code> 的效果。</p>
<p>如果函数内注册了多个 <code>defer</code>函数，最终结果会按照注册顺序逆序执行。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func A() &#123;  
    fmt.Println(&quot;A&quot;)  
&#125;  
  
func B() &#123;  
    //defer用来执行释放连接  
    defer func() &#123;  
       err := recover()  
       //recover会尝试恢复panic之前的操作并向后执行  
       fmt.Println(err)  
       fmt.Println(&quot;释放连接。。&quot;)  
    &#125;()  
    panic(&quot;ERROR!!&quot;) //程序崩溃退出  
    fmt.Println(&quot;B&quot;)  
&#125;  
  
func C() &#123;  
    fmt.Println(&quot;C&quot;)  
&#125;  
  
func main() &#123;  
    A()  
    B()  
    C()  
    //A  
    //ERROR!!    //释放连接。。  
    //C  
&#125;
</code></pre>
<p><code>panic</code>：提供的一种报告致命错误的方式，<code>panic</code> 发生时会中断程序运行。</p>
<p><code>recover</code>：拦截运行时 <code>panic</code>，重新获取流程控制权，并返回 <code>panic value</code>。未发生<code>panic</code>会返回 <code>nil</code>。</p>
<blockquote>
<p>注意， <code>recover</code>必须搭配 <code>defer</code> 使用。<code>defer</code> 必须在可能 <code>panic</code> 之前定义，<code>recover</code> 才能拦截到。</p>
</blockquote>
<p><code>defer</code>的实现上是由 <code>runtime._defer</code>结构体：</p>
<pre><code class="language-go">type _defer struct &#123;
    started   bool
    heap      bool
    openDefer bool
    sp        uintptr 
    pc        uintptr 
    fn        func()
    _panic    *_panic
    link      *_defer // 指向下一个 defer
    fd        unsafe.Pointer
    varp      uintptr
</code></pre>
<p><code>defer</code> 和 协程是直接关联的，<code>defer</code> 再运行时以链表形式存在，链表头在协程 <code>G</code> 上，当协程执行函数时，会按照顺序将注册的 <code>defer</code> 在链表头部插入。</p>
<h3><span id="struct-结构体">Struct 结构体</span></h3><p><code>Go</code> 可以使用 <code>type</code> 关键字声明类型别名或者自定义类型。</p>
<pre><code class="language-go">type LogLevel int

type MyInt int64
</code></pre>
<p>结构体是一种自定义类型，由<code>type</code>和 <code>struct</code> 关键字和 一对 <code>&#123;&#125;</code> 包含一组结构体成员构成（可以不使用 <code>type</code> 关键字声明无名结构体）。</p>
<p>同时需要注意，<code>Go</code> 未设置 <code>public</code>、<code>private</code> 类似的访问修饰符，所以采用了根据首字母大小写区分内部字段释放导出（首字母大写为导出，否则仅包内部可见，函数同样如此）。</p>
<pre><code class="language-go">struct &#123;
	want: 0,
	got: 1,
	args: []
&#125;

type Logger &#123;
	io.Writer
	Filename string
&#125;
</code></pre>
<p>对于<code>Go</code>来说，结构体的尺寸为它所有字段的尺寸加上可能的填充的字节数（通常编译器会在结构体值的两个相邻字段直接填充一些字节来保证一些字段的地址总是某个整数的倍数）。</p>
<blockquote>
<p>特殊的：空结构体的尺寸为零。</p>
</blockquote>
<p>同时每个结构体可以被指定一个标签 <code>tag</code>。语法上来说，这个标签可以是任意的，默认为空字符串，实践过程中其应该被表示为一个 <strong>空格分隔的键值对</strong>形式。</p>
<pre><code class="language-go">type LogOptions struct &#123;  
    // 输出日志等级  
    Level LogLevel `json:&quot;level&quot;`  
    // 日期输出格式  
    Layout string `json:&quot;layout&quot;`  
  
    // 文本格式输出前缀  
    TextPrefix string `json:&quot;text_prefix&quot;`  
    // 日志输出格式标志  
    TextFlag LTextFlag `json:&quot;text_flag&quot;`  

    // Json格式一些默认字段的key  
    TimeEncodeKey    string `json:&quot;time_encode_key&quot;`  
    SourceEncodeKey  string `json:&quot;source_encode_key&quot;`  
    LevelEncodeKey   string `json:&quot;level_encode_key&quot;`  
    MessageEncodeKey string `json:&quot;message_encode_key&quot;`  
    FieldEncodeKey   string `json:&quot;field_encode_key&quot;`  
&#125;
</code></pre>
<p>这些 <code>tag</code> 在相关的序列化和反序列化中常用，比如 <code>json</code> 、<code>xml</code>。如果想要获取这些 <code>tag</code> 的值可以 通过反射。</p>
<blockquote>
<p><code>Go</code> 不存在 <code>Union</code> 联合体</p>
</blockquote>
<h3><span id="channel-通道">Channel 通道</span></h3><p>通道主要是配合协程实现并发同步。他的设计理念是：<strong>不要让计算通过共享内存来通讯，而是应该让他们通过通信来共享内存</strong>。</p>
<p>而 <code>channel</code> 可以视为一个 <strong>先进先出(<code>FIFO: first in first out</code>)队列</strong>。一些协程向此通道发送数据，由另一些协程进行处理。</p>
<p>随着一个数据值的传递，一些数据值的所有权从一个协程转移到了另一个协程。即协程发送一个值到<code>channel</code> 可以视为此协程释放了一些值的所有权，协程从通道接受到一个值，可以认为此协程获取了一些值的所有权（也可能没有任何所有权发生转移）。</p>
<p>通道分为单项和双向：</p>
<ul>
<li><code>chan T</code>：视为元素类型<code>T</code> 的双向通道，编译器允许从其接收和发送数据。</li>
<li><code>chan&lt;- T</code>：视为元素类型 <code>T</code> 的单向发送通道，编译器只允许向其发送数据。</li>
<li><code>&lt;-chan T</code>：视为元素类型 <code>T</code> 的单向接收通道，编译器只允许从其接收数据。</li>
</ul>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
)  
  
func Scanner(in chan&lt;- string) &#123;  
    // 只允许发送数据  
    for i := 0; i &lt; 20; i++ &#123;  
       in &lt;- &quot;Hello World!&quot;  
    &#125;  
    close(in)  
&#125;  
  
func Printer(out &lt;-chan string) &#123;  
    for msg := range out &#123;  
       fmt.Println(msg)  
    &#125;  
&#125;  
  
func Processor(out &lt;-chan string, in chan&lt;- string) &#123;  
    for msg := range out &#123;  
       in &lt;- msg  
    &#125;  
    close(in)  
&#125;  
  
func main() &#123;  
    in := make(chan string)  
    go Scanner(in)  
    out := make(chan string)  
    go Processor(in, out)  
  
    Printer(out)  
&#125;
</code></pre>
<p><strong>所有的通道均为可比较类型</strong>。其值为引用类型，通道的赋值会使得多个通道值共享底层部分。</p>
<p>通道有几个基本操作：</p>
<ul>
<li>关闭 ，通过内建函数<code>close</code></li>
</ul>
<pre><code class="language-go">close(ch)
</code></pre>
<ul>
<li>发送，需要注意，其不能为单向接收通道，<code>&lt;-</code> 为数据发送操作符</li>
</ul>
<pre><code class="language-go">ch &lt;- v
</code></pre>
<ul>
<li>接收，需要注意，其不能为单向接收通道，<code>&lt;-</code> 为数据接收操作符。如果一个通道操作不永久阻塞，其至少会返回一个值。</li>
</ul>
<pre><code class="language-go">v := &lt;- ch

// ok 表示第一个值释放时通道被关闭之前返回的
v, ok := &lt;- ch
</code></pre>
<ul>
<li>查询容量</li>
</ul>
<pre><code class="language-go">cap(ch)
</code></pre>
<ul>
<li>查询通道长度</li>
</ul>
<pre><code class="language-go">len(ch)
</code></pre>
<blockquote>
<p>通道操作都是并发安全的。</p>
</blockquote>
<p>对不同状态的通道进行相关操作会得到不同的结果，可以参考下表：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">零值(<code>nil</code>)通道</th>
<th align="center">非零值已关闭</th>
<th align="center">非零值未关闭</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关闭</td>
<td align="center"><code>panic</code></td>
<td align="center"><code>panic</code></td>
<td align="center">成功关闭</td>
</tr>
<tr>
<td align="center">发送数据</td>
<td align="center">永久阻塞</td>
<td align="center"><code>panic</code></td>
<td align="center">阻塞或者发送成功</td>
</tr>
<tr>
<td align="center">接收数据</td>
<td align="center">永久阻塞</td>
<td align="center">永不阻塞</td>
<td align="center">阻塞或成功接收</td>
</tr>
<tr>
<td align="center"><strong>通道的元素值的传递都是复制过程</strong>，从一个协程传递到另一个协程，此值被复制至少一遍。如果值传递过程中在某个通道的缓存队列中停留过，则在传递过程中被复制两次，一次在推入通道队列的时候，一次为从缓冲队列取出的时候。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>官方编译器最大支持的通道元素类型尺寸为 <code>65535</code>，值传递的过程中，只有直接值被复制。</p>
</blockquote>
<p>可以使用 <code>for-range</code> 来循环从通道中接收元素直到通道关闭并且他的缓冲队列为空。不同于 <code>slice</code>、<code>map</code>，通道只能出现一个循环变量用于存储接收到的值。</p>
<pre><code class="language-go">for v := range ch &#123;
	// todo
&#125;
</code></pre>
<p>同时为 <code>channel</code> 专门设计了 <code>select-case</code> 分支流程控制语法（类似与 <code>switch-case</code>）。对于 <code>select-case</code>中的所有非阻塞的 <code>case</code>，会<strong>随机</strong>选择一个执行，如果所有的 <code>case</code> 都阻塞且未添加 <code>default</code> 分支，会阻塞当前协程。</p>
<pre><code class="language-go">package main  
  
import (  
    &quot;context&quot;  
    &quot;fmt&quot;    &quot;time&quot;)  
  
func main() &#123;  
    ctx, ctxCancel := context.WithCancel(context.Background())  
    ticker := time.NewTicker(time.Second)  
    for &#123;  
       select &#123;  
       case &lt;-ctx.Done():  
          fmt.Println(&quot;exit&quot;)  
          return  
       case &lt;-ticker.C:  
          fmt.Println(&quot;tick&quot;)  
          ctxCancel()  
       &#125;  
    &#125;  
&#125;
</code></pre>
<p>对于 <code>select-case</code>流程的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/select.go">实现机制</a>：</p>
<ol>
<li><p>将所有 <code>case</code> 中的 通道表达式和发送值表达式按照 从上到下、从左到右 的顺序估值。在赋值语句中作为源值的数据接收操作对应的目标值在此时不需要被估值。</p>
</li>
<li><p>将所有的分支随机排序，<code>default</code> 总是在最后。所有<code>case</code> 操作的通道可能是重复的。</p>
</li>
<li><p>为了防止下一步操作中出现死锁，对所有的 <code>case</code> 操作中相关的通道进行排序（这个顺序并不重要，官方编译器使用通道的地址顺序进行排序），排序前<code>N</code>个（<code>N</code>为<code>case</code>中涉及到的不重复通道数）通道不存在重复情况。</p>
</li>
<li><p>按照上一步生产的通道锁顺序获取所有相关的通道的锁。（<strong>通道锁顺序</strong>是针对排序结果中前 <code>N</code>个通道来说的，<strong>通道锁逆序</strong>是指此顺序的逆序）</p>
</li>
<li><p>按照随机排序后的<code>case</code>分支顺序来顺序检查相应分支：</p>
<ol>
<li>如果是 <code>case</code> 且 相应通道操作是向已关闭通道发送数据，则根据<strong>通道锁逆序</strong>解锁所有通道并在当前协程产生 <code>panic</code>，结束。</li>
<li>如果是 <code>case</code> 且 相应通道非阻塞，按照<strong>通道锁逆序</strong>解锁所有通道并执行相应的 <code>case</code> 分支代码块（此操作可能会唤醒另一个阻塞的协程），结束。</li>
<li>如果是 <code>default</code>，按照<strong>通道锁逆序</strong>解锁所有通道，并执行 <code>default</code>代码，结束。</li>
</ol>
</li>
<li><p>如果 <code>default</code> 不存在且所有的 <code>case</code> 均阻塞，将当前协程（包含对应的 <code>case</code>信息）推入每个 <code>case</code> 对应的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong>。（当前协程可能多次被推入同一个通道的这两个队列中，因为多个·<code>case</code> 操作对应的通道可能为同一个）</p>
</li>
<li><p>当前协程进入阻塞状态并按照<strong>通道锁逆序</strong>解锁所有通道。</p>
</li>
<li><p>等待其他协程通过通道操作唤醒当前协程。</p>
</li>
<li><p>如果被其他协程的通道操作唤醒，目标操作可能是关闭通道或者数据的接收或者发送操作。</p>
<ol>
<li>如果是数据发送或者接收操作，执行对应<code>case</code>，过程中当前协程将从对应的<code>case</code>操作相关的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong> <strong>弹出</strong>。</li>
</ol>
</li>
<li><p>按照<strong>通道锁顺序</strong>获取所有相关通道的锁。</p>
</li>
<li><p>将当前协程从各个 <code>case</code> 操作中对应的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong>  （可能以非弹出的方式）<strong>移除</strong>。<br>1. 如果是被关闭操作唤醒，执行5<br>2. 如果是被数据发送&#x2F;数据接收操作唤醒，目标<code>case</code>在9中已经知晓。按照<strong>通道锁逆序</strong>解锁所有通道并执行目标 <code>case</code>。</p>
</li>
<li><p>结束。</p>
</li>
</ol>
<h2><span id="面向对象">面向对象</span></h2><h3><span id="方法methodamp接收者receiver">方法<code>Method</code>&amp;接收者<code>Receiver</code></span></h3><p><code>Go</code>没有 <code>Class</code> 但是支持一些面向对象的特性。比如为类型 <code>T</code> 和 <code>*T</code> 显示地声明一个方法（方法基本上跟函数类似），其中类型 <code>T</code> 必须满足条件：</p>
<ol>
<li>需要是一个自定义类型</li>
<li><code>T</code>类型需要和方法声明在同一个包</li>
<li><code>T</code> 不能是一个指针或者接口类型</li>
</ol>
<p>类型<code>T</code>和 <code>*T</code> 即为各自方法的属主（接收者）类型。类型 <code>T</code>为 <code>T</code> 和 <code>*T</code> 声明的所有方法的属主基类型。如果为类型声明了某方法，即该类型拥有此方法。</p>
<p>每个方法对应着一个隐式声明的函数：</p>
<pre><code class="language-go">type Book struct &#123;  
    pages int  
&#125;  
  
func (b Book) Pages() int &#123;  
    return b.pages  
&#125;  
func (b *Book) SetPages(pages int) &#123;  
    b.pages = pages  
&#125;

// 对应隐式函数 
// 由此也可以看出，如果需要修改接收者变量的数据，请使用指针接收者
func Book.Pages(b Book) int &#123;  
    return b.pages // 此函数体和Book类型的Pages方法体一样  
&#125;  
func (*Book).SetPages(b *Book, pages int) &#123;  
    b.pages = pages // 此函数体和*Book类型的SetPages方法体一样  
&#125;
</code></pre>
<blockquote>
<p>这种类型函数只能由编译器隐式声明。</p>
</blockquote>
<p>如果需要实现面向对象的继承效果，可以通过结构体嵌套实现模拟（同时注意嵌套结构体的字段冲突）。</p>
<pre><code class="language-go">type commonHandler struct &#123;  
    mutex       sync.Mutex  
    writeSyncer io.Writer  
    opts        *LogHandlerOptions  
&#125;

type JsonHandler struct &#123;  
    *commonHandler  
&#125;

type TextHandler struct &#123;  
    *commonHandler  
&#125;
</code></pre>
<h3><span id="接口-interface">接口 <code>Interface</code></span></h3><p>接口是一种特殊的类型，其可以包裹非接口值实现反射、多态。同时在 <code>go1.18</code>开始，自定义泛型被引入， 接口类型也可以用作泛型约束。</p>
<p>这也导致了 <code>go1.18</code>之前所有的接口与均可用作值类型，<code>go1.18</code>以后，有些接口只能用作类型约束。可用于值类型的接口成为基本接口类型（这里主要是基本接口类型）。</p>
<p>接口类型是通过内嵌若干接口元素来定义类型条件的，目前支持两种接口元素：方法元素和类型元素。</p>
<pre><code class="language-go">type error interface &#123;  
    Error() string  
&#125;

// go1.18之前 只有接口类型可以内勤在接口类型中
// 即接口多继承
type WriteSyncer interface &#123;  
    io.WriteCloser  
    Sync() error  
&#125;

// go1.18以后  接口类型可以作为泛型约束
// PointerConstraint 指针类型泛型约束  
type PointerConstraint[T any] interface &#123;  
    ~*T  
&#125;  
  
type Option[T PointerConstraint[U], U any] interface &#123;  
    Apply(T)  
&#125;  
  
type optionFunc[T PointerConstraint[U], U any] func(T)  
  
func (f optionFunc[T, U]) Apply(o T) &#123;  
    f(o)  
&#125;  
  
type options struct &#123;  
    name string  
&#125;  
  
func WithOptions(name string) Option[*options, options] &#123;  
    return optionFunc[*options, options](func(o *options) &#123;  
       o.name = name  
    &#125;)  
&#125;
</code></pre>
<blockquote>
<p>需要注意：接口实现是隐式的，其关注行为而非类型。</p>
</blockquote>
<p>空接口是一个特殊的接口类型，其没有内嵌任何方法或类型。同时在 <code>Go1.18</code>引入了空接口的类型别名 <code>any</code>。</p>
<p><strong>因为空接口不包含任何方法，因此所有类型都实现了空接口</strong>。</p>
<pre><code class="language-go">type any = interface&#123;&#125;
</code></pre>
<p>一个接口值中存储的动态类型信息可以被用来检视此接口值的动态值和操纵此动态值所引用的值。 这称为反射。</p>
<p>针对接口，我们常用的是<strong>类型断言</strong>。语法格式为 <code>i.(T)</code>，其中 <code>i</code> 为一个接口值，<code>T</code> 为一个类型名或者自定义类型（可以为任意一个非接口类型或者任意一个接口类型）。</p>
<pre><code class="language-go">func test() &#123;  
    // 编译器将把123的类型推断为内置类型int。  
    var x interface&#123;&#125; = 123  
    // 情形一：  
    n, ok := x.(int)  
    fmt.Println(n, ok) // 123 true  
    n = x.(int)  
    fmt.Println(n) // 123  
    // 情形二：  
    a, ok := x.(float64)  
    fmt.Println(a, ok) // 0 false  
    // 情形三：  
    a = x.(float64) // 将产生一个恐慌  
&#125;
</code></pre>
<p>如果出现针对接口值相关的比较：</p>
<ul>
<li>比较一个接口值和非接口值</li>
<li>比较两个接口</li>
</ul>
<p>对于非接口值的类型，必须实现了接口值的类型，所以可以隐式转换为两个接口的比较。而比较两个接口值，即比较两个接口值的动态类型和动态值：</p>
<ol>
<li>其中一个接口时 <code>nil</code> ，则比较另一个接口是否也为 <code>nil</code></li>
<li>如果这两个接口值的动态类型不一样，则比较结果为 <code>false</code></li>
<li>如果其动态类型一样：<ol>
<li>动态类型为不可比较类型，<code>panic</code></li>
<li>比较动态值的比较结果</li>
</ol>
</li>
</ol>
<p>即：只有两个接口都为 <code>nil</code> 或者两个接口的动态值、动态类型相同为可比较类型且动态值相等时为 <code>true</code>。</p>
<p><code>Go</code> 中针对非空接口和接口底层上有两种实现，即 <code>iface</code> 和 <code>eface</code>。其中 <code>eface</code> 即 <code>empty interface</code> 表示不含 <code>method</code> 的接口（也就是空接口）。</p>
<pre><code class="language-go">type _type struct &#123;  
    size       uintptr  // type size  
    ptrdata    uintptr  // size of memory prefix holding all pointers    
    hash       uint32   // hash of type; avoids computation in hash tables    
    tflag      tflag    // extra type information flags  
    align      uint8    // alignment of variable with this type  
    fieldalign uint8    // alignment of struct field with this type  
    kind       uint8    // enumeration for C  
    alg        *typeAlg // algorithm table  
    gcdata     *byte    // garbage collection data  
    str        nameOff  // string form  
    ptrToThis  typeOff  // type for pointer to this type, may be zero  
&#125;

type eface struct &#123;
	// 数据类型的描述
    _type *_type
    // 具体的类型
    data  unsafe.Pointer  
&#125;

// layout of Itab known to compilers  
// allocated in non-garbage-collected memory  
// Needs to be in sync with  
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.  
type itab struct &#123;  
    inter  *interfacetype  
    _type  *_type  
    link   *itab  
    bad    int32  
    inhash int32      // has this itab been added to hash?    fun    [1]uintptr // variable sized  
&#125;

type iface struct &#123;
	// 接口元信息 可以理解为 pair&lt;接口类型, 具体类型&gt;
    tab  *itab  
    data unsafe.Pointer  
&#125;
</code></pre>
<h3><span id="泛型">泛型</span></h3><p><code>go1.18</code>中正式引入泛型。其并未完全采用类似 <code>C++/Rust</code> 这种为每个用到的类型都生成一份模板代码，这样虽然性能好，但是答复拖慢编译速度，同时导致编译的二进制文件体积膨胀。也不是完全采用编译时生成类型字典存储在只读数据段，在调用时根据字典查询类型信息，这样会导致巨大的运行时开销，性能较差。</p>
<p><code>Go</code> 的泛型采用一个折中的选择，对于同种内存形状（由内存分配器决定），使用单态化，为其生成同一份代码（比如 <code>type MyInt int</code> 和 <code>int</code> ）。但是对于指针而言，所有的指针类型都是一个内存形状，此时则是采取字典方式在运行时获取类型信息。所以 <code>Go</code> 的泛型仍然存在运行时开销。</p>
<p>同时，<code>go1.18</code>后接口的定义也变成了类型集，含有类型集的接口又称为通用接口。</p>
<pre><code class="language-go">type Conn[T net.Conn | websocket.Conn] struct &#123;  
    conn T  
&#125;

// 并集  
type SignedInt interface &#123;  
    int8 | int16 | int | int32 | int64  
&#125;  
  
type UnSignedInt interface &#123;  
    uint8 | uint16 | uint32 | uint64  
&#125;  
  
type Integer interface &#123;  
    SignedInt | UnSignedInt  
&#125;  
  
// 交集  
type Number interface &#123;  
    SignedInt  
    Integer
&#125;

// 底层类型 使用 ~
type Int interface &#123;  
    ~int8 | ~int16 | ~int | ~int32 | ~int64 | ~uint8 | ~uint16 | ~uint | ~uint32 | ~uint64  
&#125;
</code></pre>
<blockquote>
<p>如果交际为空，即为空集，传递任何类型都无法通过编译</p>
</blockquote>
<p>需要注意的是：</p>
<ul>
<li>泛型不能作为基础类型</li>
<li>泛型类型无法使用类型断言</li>
<li>匿名结构体不支持泛型</li>
<li>不支持泛型方法</li>
<li>类型集无法作为类型实参</li>
<li>非接口类型，类型并集中不能又交集，接口类型则允许有交集</li>
<li>类型集无法直接或间接的并入自身</li>
<li>方法集无法并入类型集</li>
</ul>
<pre><code class="language-go">// 通用的对象池
type Pool[T any] struct &#123;  
    pool sync.Pool  
&#125;  
  
func NewPool[T any](fn func() T) *Pool[T] &#123;  
    return &amp;Pool[T]&#123;  
       pool: sync.Pool&#123;  
          New: func() any &#123;  
             return fn()  
          &#125;,  
       &#125;,  
    &#125;  
&#125;  
  
func (gs *Pool[T]) Get() T &#123;  
    return gs.pool.Get().(T)  
&#125;  
  
func (gs *Pool[T]) Put(element T) &#123;  
    gs.pool.Put(element)  
&#125;
</code></pre>
<h3><span id="迭代器">迭代器</span></h3><p><code>go1.23</code> 中对 <code>for-range</code> 支持了 <code>range over func</code>。这样就可以使用自定义迭代器了。</p>
<p>其本质上是一个闭包函数，接收一个回调函数作为参数，迭代过程会将序列中的元素逐个传递给回调函数 <code>yield</code>。</p>
<ul>
<li>推送式迭代器（<code>pushing iterator</code>）：由迭代器控制迭代逻辑，用户被动获取元素</li>
</ul>
<pre><code class="language-go">// iter 标准库定义的迭代器类型
// 只接受一个参数 
type Seq[V any] func(yield func(V) bool)

// 接收两个参数
type Seq2[K, V any] func(yield func(K, V) bool)

// 参考
for f := range Fibonacci(n) &#123;
    fmt.Println(f)
&#125;
// 等同于 
Fibonacci(n)(func(f int) bool &#123;
    fmt.Println(f)
    return true
&#125;)
</code></pre>
<ul>
<li>拉取式迭代器（<code>pulling iterator</code>）：由用户来控制迭代逻辑，主动的去获取序列元素。</li>
</ul>
<pre><code class="language-go">// iter 库定义的拉取式迭代器 采用闭包记录状态
// 可以将推送式迭代器转换为拉取式迭代器
// 都接收一个迭代器作为参数，返回两个函数 stop() 和 next() 用于控制携带继续和停止
// next 会返回被迭代的元素和一个表示当前值释放有效的布尔值 结束时返回0值
// 当不使用迭代器后 一定要调用 stop
// 迭代器不是并发安全的
func Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())

func Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())

// 参考
func ScanLines(reader io.Reader) iter.Seq2[string, error] &#123;  
    scanner := bufio.NewScanner(reader)  
    return func(yield func(string, error) bool) &#123;  
       for scanner.Scan() &#123;  
          if !yield(scanner.Text(), scanner.Err()) &#123;  
             return  
          &#125;  
       &#125;  
    &#125;  
&#125;
</code></pre>
<h2><span id="工具链">工具链</span></h2><h3><span id="包管理">包管理</span></h3><p><code>Go</code>中的包定义必须在代码开始之前，使用 <code>package</code> 关键字定义。（其之前可能存在相关的编译约束）</p>
<pre><code class="language-go">//go:build linux  
// +build linux  
  
package utils
</code></pre>
<p>包的定义有如下规则：</p>
<ul>
<li>一个文件夹下只能由一个包，同一个包文件不能分散多个文件夹</li>
<li>包名可以不同于文件夹名，包名不能带 <code>-</code></li>
<li><code>main</code> 包为程序入口，编译时不含 <code>main</code>的源代码不会得到可执行文件</li>
<li>包中的标识符以首字母大写表示对外暴露，首字母小写表示私有</li>
</ul>
<p>使用 <code>import</code> 关键字导入包，如果不使用 <code>go mod</code> 模式，包名从 <code>$GOPATH/src/</code> 后开始计算。同时为了规范，一般采用如下格式：</p>
<pre><code class="language-go">package main

import (
	// 标准库
	stdsql &quot;database/sql&quot;

	// 项目库
	logger &quot;common/logger&quot;

	// 第三方库
	_ &quot;github.com/go-sql-driver/mysql&quot;
)
</code></pre>
<blockquote>
<p><code>Go</code> 中禁止循环导入包 </p>
</blockquote>
<p><code>Go</code>中可以在每个包声明 <code>init()</code> 函数来实现包中一些相关变量的初始化，这个函数会在包首次被导入时字段触发。<code>init()</code> 函数没有参数也没有返回值，只能在程序运行时自动被调用，不能再代码中主动调用。</p>
<pre><code class="language-bash">// 导入顺序
main--&gt; import --&gt;A-- import --&gt;B-- import --&gt;C
// 执行顺序
main.init()&lt;---A.init()&lt;---B.init()&lt;---C.init()
</code></pre>
<p>在古老时代<code>Go</code>还曾用过 <code>Vendor</code> 作为包管理，但是后面基本上被官方的 <code>go modules</code>给统一了。</p>
<pre><code class="language-bash">export GO111MODULE=on
</code></pre>
<blockquote>
<p>现在依然可以开启 <code>vendor</code> 来作为项目的本地包管理：<code>go build -mod=vendor</code></p>
</blockquote>
<p>常规的<code>go.mod</code>相关定义：</p>
<pre><code class="language-go">// module 定义模块路径
module projectName  

// go 版本
go 1.24.1

// require 包+版本号
// // indirect 表示间接依赖 
require google.golang.org/protobuf v1.36.5 // indirect

// replace 提供模块路径 或者版本
require common v0.0.0
replace common =&gt; ./common

// exclude 排除特定版本
exclude (  
    github.com/bad/module v1.2.3  
)
</code></pre>
<p><code>go.sum</code> 文件记录了每个依赖性的哈希值和版本信息，以确保依赖性的一致性和完整性。其不是 <code>go.mod</code>的一部分但是和其密切相关。</p>
<pre><code class="language-bash">⮞  go mod help
Go mod provides access to operations on modules.

Note that support for modules is built into all the go commands,
not just &#39;go mod&#39;. For example, day-to-day adding, removing, upgrading,
and downgrading of dependencies should be done using &#39;go get&#39;.
See &#39;go help modules&#39; for an overview of module functionality.

Usage:

        go mod &lt;command&gt; [arguments]

The commands are:

        download    download modules to local cache
        edit        edit go.mod from tools or scripts
        graph       print module requirement graph
        init        initialize new module in current directory
        tidy        add missing and remove unused modules
        vendor      make vendored copy of dependencies
        verify      verify dependencies have expected content
        why         explain why packages or modules are needed

Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.
</code></pre>
<p>在 <code>Go1.18</code> 以后，子模块可以通过工作区的模式实现，其能给在本地项目的 <code>go.work</code> 文件中，通过设置一系列以来的模块本地路径，再将<strong>路径下的模块组成一个当前的工作区</strong>，他的读取优先级是最高的。</p>
<pre><code class="language-bash">⮞  go work help

Usage:

        go work &lt;command&gt; [arguments]

The commands are:

        edit        edit go.work from tools or scripts
        init        initialize workspace file
        sync        sync workspace build list to modules
        use         add modules to workspace file
        vendor      make vendored copy of dependencies

Use &quot;go help work &lt;command&gt;&quot; for more information about a command.
</code></pre>
<p>生成的 <code>work</code>文件可以参考：</p>
<pre><code class="language-go">go 1.24.1  
  
use (  
    .  
    ./common
)
  
replace (  
    golang.org/x/net =&gt; example.com/fork/net v1.4.5  
)
</code></pre>
<p><code>go.work</code> 的 <code>replace</code> 优先级会高于 <code>go.mod</code>中的 <code>replace</code>指令。</p>
<blockquote>
<p>可以通过 <code>-workfile=off</code>来禁用工作区模式</p>
</blockquote>
<p>由于 <code>Go</code> 编译的情况可能比较复杂，建议遇到复杂编译情况时可以使用 <code>makefile</code> 或者 编写编译脚本来完成。</p>
<h2><span id="异步编程">异步编程</span></h2><h3><span id="协程">协程</span></h3><p><code>Go</code>不提供线程的创建方式，采用 <code>goroutine</code> 协程来实现并发异步。相对于 <code>thread</code> 其更轻量级，<code>goroutine</code> 处于用户态完全由<code>go</code>的协程调度器调度完成。</p>
<p>其可以通过 <code>channel</code>等机制实现 <code>goroutine</code> 之间的同步等操作。对于 <code>go</code>来说，每个函数都是一个并发单元，可以通过 <code>go</code> 关键字为函数创建一个 <code>goroutine</code>。</p>
<pre><code class="language-go">func (gs *TcpConnectionKeeper) startBroker(broker ConnectionBroker) &#123;  
    defer broker.Close()  
  
    cid := broker.ConnectionID()  
    if cid == &quot;&quot; || cid != gs.connID &#123;
       return  
    &#125;  
  
    heartbeatAckChan := make(chan ControlPacket)  
    defer close(heartbeatAckChan)  
  
    ctxTask, ctxTaskCancel := context.WithCancel(gs.ctx)  
    defer ctxTaskCancel()  
  
    wg := sync.WaitGroup&#123;&#125;  
  
    wg.Add(1)  
    go func() &#123;  
       defer wg.Done()  
       defer ctxTaskCancel()  
       gs.readLoop(ctxTask, broker, heartbeatAckChan)  
    &#125;()  
  
    wg.Add(1)  
    go func() &#123;  
       defer wg.Done()  
       defer ctxTaskCancel()  
       gs.writeLoop(ctxTask, broker)  
    &#125;()  
  
    heartbeat := broker.Keepalive()  
    if heartbeat &gt; 0 &#123;  
       wg.Add(1)  
       go func() &#123;  
          defer wg.Done()  
          defer ctxTaskCancel()  
          gs.keepaliveLoop(ctxTask, heartbeat, heartbeatAckChan)  
       &#125;()  
    &#125;  
  
    wg.Wait()  
&#125;
</code></pre>
<p><code>Go</code> 中的 <code>goroutine</code> 属于<strong>有栈协程</strong>，不同于 <code>js</code> 的 <code>Promise</code>，<code>goroutine</code> 有自己的寄存器上下文，和底层线程属于 <code>M:N</code> 的关系。<code>js</code> 的 <code>Promise</code> 是 无栈协程的实现方式，本质上是 <strong>事件循环</strong>。</p>
<p>多个 <code>goroutine</code> 同时操作一个资源（临界区）时，同样会发送数据竞争问题。官方提供了 <code>sync</code>包来处理控制访问共享资源的方法。</p>
<h3><span id="锁-mutex">锁 <code>Mutex</code></span></h3><p>互斥锁时一种常用的控制共享资源访问的方法，它能保证同时只有一个 <code>goroutine</code> 可以访问共享资源。在 <code>Go</code> 中主要实现为 <code>sync.Mutex</code> 和 <code>synx.RWMutex</code>，他们都实现了 <code>sync.Locker</code>接口。</p>
<p>其中 <code>sync.RWMutex</code> 还有 <code>RLock()</code> 和 <code>RUnlock()</code> 方法用来支持多个读取着读取同一份数据但防止此数据被多个 <code>goroutine</code> 写入。</p>
<pre><code class="language-go">package main  

import (  
	&quot;fmt&quot;  
	&quot;runtime&quot;  
	&quot;sync&quot;  
) 

type Counter struct &#123;  
    m sync.Mutex  
    n uint64  
&#125;  
  
func (c *Counter) Value() uint64 &#123;  
    c.m.Lock()  
    defer c.m.Unlock()  
    return c.n  
&#125;

func (c *Counter) Increase(delta uint64) &#123;  
    c.m.Lock()  
    c.n += delta  
    c.m.Unlock()  
&#125;

func main() &#123;  
    var c Counter  
    for i := 0; i &lt; 100; i++ &#123;  
       go func() &#123;  
          for k := 0; k &lt; 100; k++ &#123;  
             c.Increase(1)  
          &#125;  
       &#125;()  
    &#125;  
    // 仅演示  
    for c.Value() &lt; 10000 &#123;  
       runtime.Gosched()  
    &#125;  
    fmt.Println(c.Value()) // 10000  
&#125;
</code></pre>
<p>对于 <code>sync.RWMutex</code> ，其读锁维护有计数器，每次加锁成功计数器加一，解锁时减一。零计数表示其读锁处于为枷锁状态。对于一个可寻址的 <code>sync.RWMutex</code>：</p>
<ul>
<li>写锁只在其读锁和写锁都处于未加锁状态才能成功加锁。</li>
<li>写锁处于加锁状态时，任何加锁操作都将导致当前协程阻塞直到写锁释放才有可能操作成功。</li>
<li>读锁处于加锁状态，新加写锁会导致协程阻塞。</li>
<li>读锁处于加锁状态，为避免写入者永远无法获取成功写锁，在某个被阻塞的加写锁操作之后的所有加读锁操作也会被阻塞。</li>
<li>写锁处于加锁状态，为避免读取者永远无法加读锁，发送在写锁下一次被解锁操作之前的加读锁操作都将在此写锁下一次被解锁之后成功。</li>
</ul>
<blockquote>
<p>注意：锁并不绑定某个协程，也不纪律哪个协程成功加锁。</p>
</blockquote>
<h3><span id="等待组-waitgroup">等待组 <code>WaitGroup</code></span></h3><p>每个等待组 <code>sync.WaitGroup</code> 都在内部维护着一个技术，初始为0。</p>
<pre><code class="language-go">type WaitGroup struct &#123;  
    noCopy noCopy
	// high 32 bits are counter, low 32 bits are waiter count. 
    state atomic.Uint64
    sema  uint32
&#125;  

func (wg *WaitGroup) Add(delta int) &#123;
	// 如果添加一个负值或者调用 wg.Done() 使得计数器变为负数
	// 会产生 panic
&#125;

func (wg *WaitGroup) Done() &#123;
	// 说明 wg.Done 和 wg.Add(-1) 是等价的
    wg.Add(-1)  
&#125;  

func (wg *WaitGroup) Wait() &#123;
&#125;
</code></pre>
<p>当一个协程调用 <code>wg.Wait()</code>时：</p>
<ul>
<li>如果 <code>wg</code> 计数器为0，<code>wg.Wait()</code> 为一个空操作。</li>
<li>如果有值，则协程阻塞等待计数器变为0。</li>
</ul>
<h3><span id="多协程间通知-cond">多协程间通知 <code>Cond</code></span></h3><p>如果想确保某个操作只会被一个协程且只会执行一次可以使用 <code>sync.Once</code>：</p>
<pre><code class="language-go">var (  
    defaultLogger atomic.Pointer[Logger]  
    once          sync.Once  
)  
  
func init() &#123;
	// once 只有一个方法 Do(f func())
    once.Do(func() &#123;  
       defaultLogger.Store(NewLogger(NewTextHandler(os.Stdout, WithTextFlag(DefaultBitFlag), WithLevelEnabler(TraceLevel))))  
    &#125;)  
&#125;
</code></pre>
<p>如果需要实现多个协程间通知，可以使用 <code>sync.Cond</code>。每个 <code>sync.Cond</code> 拥有一个字段<code>L</code>为 <code>sync.Locker</code> 类型，具体通常为 <code>*sync.Mutex</code> 或者 <code>*sync.RWMute</code>。</p>
<p>其提供三个接口：<code>Wait()</code>、<code>Signal()</code>、<code>Broadcast()</code>。</p>
<p>每个 <code>Cond</code> 维护有一个 先进先出等待协程队列，对于一个可寻址的 <code>Cond</code>：</p>
<ul>
<li><code>Wait()</code> 必须在 <code>L</code> 字段处于加锁状态时调用，否则产生 <code>panic</code>。调用成功时：<ul>
<li>先将协程推到等待协程队列</li>
<li>调用 <code>L.Unlock()</code> 解锁</li>
<li>使当前协程阻塞，等待其他协程从高 <code>Signal()</code>、<code>Broadcast()</code> 唤醒。如果成功被唤醒将试图重新加锁，加锁成功后 <code>Wait()</code> 调用退出</li>
</ul>
</li>
<li><code>Signal()</code> 将唤醒并移除等待协程队列中的第一个协程（不为空）</li>
<li><code>Broadcast()</code> 将唤醒并移除等待队列中的所有协程</li>
</ul>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)  
  
func main() &#123;  
    const N = 10  
    var values [N]string  
    cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)  
    for i := 0; i &lt; N; i++ &#123;  
       d := time.Second * time.Duration(rand.Intn(10)) / 10  
       go func(i int) &#123;  
          time.Sleep(d) // 模拟一个工作负载  
          cond.L.Lock()  
          // 下面的修改必须在cond.L被锁定的时候执行  
          values[i] = string(&#39;a&#39; + i)  
          cond.Broadcast() // 可以在cond.L被解锁后发出通知  
          cond.L.Unlock()  
          // 上面的通知也可以在cond.L未锁定的时候发出。  
          //cond.Broadcast() // 上面的调用也可以放在这里  
       &#125;(i)  
    &#125;  
    // 此函数必须在cond.L被锁定的时候调用。  
    checkCondition := func() bool &#123;  
       fmt.Println(values)  
       for i := 0; i &lt; N; i++ &#123;  
          if values[i] == &quot;&quot; &#123;  
             return false  
          &#125;  
       &#125;  
       return true  
    &#125;  
    cond.L.Lock()  
    defer cond.L.Unlock()  
    for !checkCondition() &#123;  
       cond.Wait() // 必须在cond.L被锁定的时候调用  
    &#125;  
&#125;
</code></pre>
<blockquote>
<p>如有必要，多个 <code>sync.Cond</code> 可以共享一个 <code>sync.Locker</code>。</p>
</blockquote>
<h3><span id="原子操作-atomic">原子操作 Atomic</span></h3><p>原子操作是比其它同步技术更基础的操作。原子操作是无锁的，常常直接通过CPU指令直接实现。</p>
<p><code>Go</code>提供的原子操作都在 <code>sync/atomic</code> 包下，在 <code>Go1.18</code>引入泛型后，从 <code>Go1.19</code> 开始引入了 <code>atomic.Pointer[T any]</code> 泛型类型和 <code>atomic.Bool</code>。基本的原子操作存在四类：</p>
<ul>
<li>读取 <code>Load</code></li>
<li>写入 <code>Store</code></li>
<li>修改 <code>Add</code></li>
<li>交换 <code>Swap</code></li>
<li>比较并交换 <code>CompareAndSwap</code></li>
</ul>
<pre><code class="language-go">n := int32(1)  
atomic.AddInt32(&amp;n, 1)  
  
// go1.19  
n1 := atomic.Int32&#123;&#125;  
n1.Add(1)
</code></pre>
<h3><span id="gmp模型"><code>GMP</code>模型</span></h3><p>协程相较于线程，完全处于用户态的上下文切换对比线程切换需要陷入内核态更加轻量，同时协程所需要的内存占用更小。但是通常来说，协程的<code>CPU</code>调度是抢占式的，协程由用户态调度是协作式的。</p>
<p><code>go</code> 中的 <code>goroutine</code> 创建简单（只需要通过 <code>go</code> 关键字），占用小，调度由 <code>runtime</code>完成，其协程调度器主要有 <strong>G（协程）</strong>、<strong>M（系统线程）</strong>、<strong>P（逻辑处理器）</strong> 三部分组成。</p>
<p>协程的调度仍让依附于线程，即协程执行所需要的时间片来自于线程，这部分仍由操作系统调度。那如何优化协程的时间片利用便是关键：</p>
<ul>
<li><code>1:N</code>：所有协程都分配到一个内核线程，这样仅仅剩协程间的切换，但是无法利用现代 <code>CPU</code> 多核性能。</li>
<li><code>N:N</code>：一个线程对应一个协程，协程独占线程时间片，也可以更好利用多核性能，但是线程本身的创建和切换成本高，未能利用好协程优势。</li>
<li><code>M:N</code>：多个线程对应多个协程，每一个线程都会对应若干个协程，由处理器 <code>P</code> 来负责调度协程 <code>G</code> 如何使用线程的时间片。</li>
</ul>
<p><code>goroutine</code> 的协程生命周期如下：<br> <img src="goroutine_1.png" alt="goroutine_1"></p>
<blockquote>
<p><code>_Gcopystack</code> 是写正常扩张时具有的状态</p>
</blockquote>
<p><code>Go</code> 的协程时典型的有栈协程，每一个协程都会在堆上分配独立的栈空间，并且它会随着使用量的变化而增长或者缩小。</p>
<ul>
<li><p>新建协程时，<code>runtime.stackalloc</code>默认会为其分配 <code>2KB</code> 的栈空间大小。特殊情况下会根据栈内存分别从 <code>stackpool</code>和本地的线程缓存中获取。</p>
</li>
<li><p>如果不够则需要扩容，编译器会在函数开头插入 <code>runtime.morestack</code> 函数来检查当前协程释放需要进行栈扩容</p>
</li>
<li><p>需要则会通过 <code>runtime.newstack</code> 来完成真正的扩容操作，并由 <code>runtime.copystack</code>来完成栈拷贝的工作，拷贝前<code>G</code> 的状态由 <code>_Grunning</code> 切换为 <code>_Gcopystack</code>，完成后由 <code>_Gcopystack</code> 切换为 <code>_Grunning</code>。详细拷贝的过程可分为：</p>
<ul>
<li>分配新的栈空间</li>
<li>将就栈内存通过 <code>runtime.memmove</code> 直接复制到新的栈空间</li>
<li>调整栈指针结构，比如 <code>defer</code>、<code>panic</code></li>
<li>更新<code>G</code> 的栈空间字段</li>
<li>通过 <code>runtime.adjustframe</code> 调整执行旧栈内存的指针</li>
<li>释放旧栈的内存</li>
</ul>
</li>
<li><p>当 <code>G</code> 的状态为 <code>_Grunable</code> 、<code>_Gsyscall</code>、<code>_Gwating</code>时，<code>GC</code> 会扫描协程栈的内存空间，并由 <code>runtime.shrinkstack</code> 来完成真正的缩容操作。</p>
</li>
</ul>
<blockquote>
<p><code>runtime.morestack</code> 几乎会在所有函数的开头都被插入，所以栈扩容检查的时机也是一个协程抢占点。</p>
</blockquote>
<p>远古时期的栈扩容采用分段栈试下，不进行内存拷贝而是申请一片新的栈空间再通过指针链接，形成栈链表。好处时不需要拷贝原有的栈，但是会十分频繁地触发栈扩容和缩容。后续 <code>go1.4</code> 改成了连续栈，连续栈分配了更大地栈空间，不会因为内存达到临界值而频繁触发扩容和缩容，并且由于内存地址是连续的，格局缓存的局部性原理，连续栈对 <code>CPU</code> 缓存也更加友好。</p>
<p><code>GMP</code> 模型如下：</p>
<p><img src="gmp_dispatch.png" alt="gmp_dispatch"></p>
<ul>
<li><strong>全局队列</strong>：存放等待运行的 <code>G</code>。</li>
<li><strong>P的本地队列</strong>：存放等待运行的 <code>G</code>，但是存放数量有限，不超过 256个。新建 <code>G</code> 会优先加入 <code>P</code>  的本地队列，如果队列满了，则会一定本地队列一半的 <code>G</code> 到全局队列。</li>
<li><strong>P列表</strong>：所有的 <code>P</code> 都由运行时创建，可由 <code>GOMAXPROCS</code> 函数设置。</li>
<li><strong>M队列</strong>：线程运行任务需要获取<code>P</code>，从 <code>P</code> 的本地队列中获取 <code>G</code> ，当 <code>P</code> 队列为空时，<code>M</code>  也会尝试从全局队列获取一批 <code>G</code> 到本地队列执行，或者从其他 <code>P</code> 的本地队列偷一半到自己的本地队列。</li>
</ul>
<blockquote>
<p><code>Go</code> 的协程调度器和 <code>OS</code> 调度是通过 <code>M</code> 结合的，每个 <code>M</code> 都代表了一个内核线程，<code>OS</code>调度去负责把内核线程分配到 <code>CPU</code> 上执行。</p>
</blockquote>
<p>协程调度器的设计策略：</p>
<ul>
<li><p><strong>复用线程</strong>：复用线程，避免频繁创建、销毁线程</p>
<ul>
<li><code>work stealing</code>机制：本线程无可运行的 <code>G</code> 时尝试从其他线程绑定的 <code>P</code>偷取 <code>G</code>执行，而非销毁线程</li>
<li><code>hand off</code>机制：本线程因为 <code>G</code> 进行系统调用阻塞时，会释放绑定的 <code>P</code>转移给其他空闲的线程执行</li>
</ul>
</li>
<li><p><strong>利用并行</strong></p>
</li>
<li><p><strong>抢占调度</strong>：对比<code>coroutine</code>要等待协程主动让出 <code>CPU</code> ，<code>groutine</code>最多占据<code>CPU</code> 一个时间片<code>10ms</code>以防止其他 <code>goroutine</code> 饿死</p>
</li>
<li><p>全局<code>G</code>队列：全局队列一如存在，当本地队列为空优先从全局队列获取，全局队列也为空则执行 <code>work stealing</code>。</p>
</li>
</ul>
<p>启动 <code>goroutine</code> 的 <code>go func()</code>调度流程如下：</p>
<p><img src="go_func.jpeg" alt="go_func"></p>
<p>调度器的生命周期如下：</p>
<p><img src="goroutine_dispatch.png" alt="goroutine_dispatch"></p>
<p>其中存在特殊的 <code>M0</code>和 <code>G0</code>：</p>
<ul>
<li><code>M0</code>：<code>M0</code>是启动程序后的编号为0的主线程，这个<code>M</code>对应的实例会在全局变量<code>runtime.m0</code>中，不需要在<code>heap</code>上分配，<code>M0</code>负责执行初始化操作和启动第一个<code>G</code>， 在之后<code>M0</code>就和其他的<code>M</code>一样了。</li>
<li><code>G0</code>：<code>G0</code>是每次启动一个<code>M</code>都会第一个创建的<code>goroutine</code>，<code>G0</code>仅用于负责调度的<code>G</code>，<code>G0</code>不指向任何可执行的函数, 每个<code>M</code>都会有一个自己的<code>G0</code>。在调度或系统调用时会使用<code>G0</code>的栈空间, 全局变量的<code>G0</code>是<code>M0</code>的<code>G0</code>。</li>
</ul>
<h2><span id="内存模型和gc">内存模型和GC</span></h2><p>操作系统在逻辑层面将进程数据分为五个部分：</p>
<ul>
<li>代码段（<code>Text Segment</code>）：通常存放程序代码，运行前已经确定，通常属于只读部分。</li>
<li>数据段（<code>Data Segment</code>）：存储已初始化的全局变量和静态变量。其在程序加载时被初始化，可读写。</li>
<li>堆（<code>Heap</code>）：用于动态内存分配，大小不固定。</li>
<li>栈（<code>Stack</code>）：存储函数局部变量、参数等。通常在编译时已经确定大小。</li>
<li>未使用段（<code>BSS Segment</code>）：用于存储程序中未初始化的全局变量和静态变量。</li>
</ul>
<p>对于参与内存管理的的角色一般为：<strong>用户程序（<code>Mutator</code>）、内存分配器（<code>Allocator</code>）、垃圾回收（<code>Collector</code>）</strong>。</p>
<p>编程语言一般包含两种内存分配器：<strong>线性分配器（<code>Sequential Allocator</code>）、空闲链表分配器（<code>Free-List Allocator</code>）</strong>。</p>
<ul>
<li>线性分配器：申请顺序从前往后分配堆内存。只需要维护一个执行内存当前分配位置的指针，用户申请内存时检查剩余空间并在返回分配内存区域后修改指针指向。</li>
</ul>
<p><img src="seqiemtial_allocator.png" alt="seqiemtial_allocator"></p>
<p>其简单但是分配的内存无法回收，并发场景下需要加锁影响性能，同时因为其是线性扩张需要屏藩整理内存。</p>
<ul>
<li>空闲链表分配器：维护空闲内存块链表，分配时通过策略找到合适的内存块</li>
</ul>
<p>使用更为广泛，其内存分配策略有：</p>
<ul>
<li>首次适应：链表头开始遍历，找到第一个大于申请内存的内存块，容易造成零散小内存。</li>
<li>循环首次适应：从上次遍历结束位置开始遍历，找到第一个大于申请内存的内存块。</li>
<li>最优适应：从链表头遍历整个链表，选择最合适的内存块。</li>
</ul>
<p>同时为了优化效率，还可以使用 <strong>隔离适应策略</strong>：将内存分割为多个链表，称之为分箱(<code>bins</code>)，每个分箱的内存块大小相同，申请内存时先找到满足条件的分箱，再从分箱中找到空闲内存块。</p>
<h3><span id="内存管理">内存管理</span></h3><p>在内存管理部分，<code>Go</code> 基于 <strong>TCMalloc</strong> 核心思想实现。</p>
<p><code>TCMalloc</code>的核心思想时将内存分为多个级别来缩小锁的粒度。内存管理部分分为两个部分：<strong>线程内存</strong> 和 <strong>页堆</strong>。</p>
<ul>
<li>线程内存：每一个内存页都被分为多个固定分配大小规格的空闲列表，用于减少碎片化。这也每一个线程都可以获得一个用于无锁分配小对象的缓冲，可以让并行程序分配小对象（<code>&lt;=32KB</code>）更加高效。</li>
</ul>
<p><img src="tc_malloc.png" alt="tc-malloc"></p>
<ul>
<li>页堆（<code>Page Heap</code>）：<code>TCMalloc</code> 管理的堆由一组页组成，一组连续的页面被表示为 <code>span</code>。当分配的对象大于 <code>32KB</code> ，将使用 页堆 进行内存分配。当没有足够的空间分配小对象则会到页堆获取内存。如果页堆页没有足够的内存，则页堆会向操作系统申请更多的内存。</li>
</ul>
<p><img src="page_heap.png" alt="page_heap"></p>
<blockquote>
<p><code>Go</code> 的内存分配器最初是基于 <code>TCMalloc</code>但是现在已经有很大不同。</p>
</blockquote>
<p><code>Go</code> 运行时调度器会在调度时会将 <strong>Goroutines(G)</strong> 绑定到 <strong>逻辑处理器(P，Logical Processors)</strong> 运行。<code>Go</code> 实现的 <code>TCMalloc</code> 将内存分为 68 种不同规格的块：</p>
<pre><code class="language-go">// sizeclasses.go

const (
    _NumSizeClasses = 68
)

var class_to_size = [_NumSizeClasses]uint16&#123;
    0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144,
    160, 176, 192, 208, 224, 240, 256, 288, 320, 352,
    384, 416, 448, 480, 512, 576, 640, 704, 768, 896,
    1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688,
    3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784,
    6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568,
    14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768,
&#125;
</code></pre>
<p><code>Go</code> 通过 <code>mspan</code> 结构体进行管理。其可以简单视为一个包含 页起始地址，页<code>span</code>规格，页数量的双端链表。</p>
<p><img src="mspan.png" alt="mspan"></p>
<p><code>Go</code>为每一个逻辑处理器（<code>P，Logical Processors</code>） 提供一个本地线程缓存（<code>local thred cache</code>）称为 <strong>mcache</strong>。所以如果 <code>goroutine</code> 需要内存可以直接从 <code>mcache</code> 获取，由于同一时间运行在只会有一个 <code>goroutine</code> 和 <code>P</code> 绑定，所以中间不需要加锁。</p>
<p><img src="mcache.png" alt="mcache"></p>
<blockquote>
<p>每个<code>mcache</code>包含所有大小规格的<code>mspan</code>作为缓存，每个 <code>P</code> 都拥有自己的 <code>mcache</code>，所以从<code>mcacahe</code> 分配内存无序持有锁。</p>
</blockquote>
<p>对于每一种大小规格，都有两种类型：</p>
<ul>
<li><strong>scan</strong>：包含指针的对象。</li>
<li><strong>noscan</strong>：不包含指针的对象。</li>
</ul>
<p>这样可以使得进行 <code>GC</code> 时回收 <code>noscan</code> 对象无须进一步扫描释放引用其他活跃对象。通过 <code>mcache</code> 在分配小对象（<code>&lt;=32KB</code>）时可以直接通过 <code>mcache</code>分配。</p>
<p>当 <code>mcache</code>没有可用空间，会从 <strong>mcentral</strong> 的 <code>mspans</code> 列表获取一个新的所需大小规格的 <code>mspan</code>。 <code>mcentral</code> 对象手机所有给定规格大小的 <code>span</code>，每个 <code>mcentral</code> 都包含两个 <code>mspan</code> 列表：</p>
<ul>
<li><code>empty mspan list</code>：没有空闲对象或者 <code>span</code> 已经被 <code>mcache</code> 缓存的 <code>span</code> 列表。</li>
<li><code>nonempty mspan list</code>：有空闲对象的 <code>mspan</code> 列表。</li>
</ul>
<p>所有的 <code>mcentral</code> 都维护在 <code>mheap</code> 结构体内。<code>Go</code> 使用 <code>mheap</code> 对象管理内存，只有一个全局变量，持有虚拟地址空间。</p>
<p><img src="mheap.png" alt="mheap"></p>
<blockquote>
<p><strong>mheap 存储了 mcentral 的数组</strong>。<strong>这个数组包含了各个的 span 的 mcentral</strong>。由于我们有各个规格的 <code>span</code> 的 <code>mcentral</code>，当一个 <strong>mcache</strong> 从 <code>mcentral</code> 申请 <strong>mspan</strong> 时，只需要在独立的 <strong>mcentral</strong> 级别中使用锁，所以其它任何 <strong>mcache</strong> 在同一时间申请不同大小规格的 <strong>mspan</strong> 将互不受影响可以正常申请。</p>
</blockquote>
<p>对于 <code>Go</code> 中对象分配流程：</p>
<ol>
<li>大于 <code>32KB</code>的大对象直接从 <code>mheap</code> 分配</li>
<li>小于 <code>16B</code> 的使用 <code>mcache</code> 的微型分配器分配</li>
<li>其余的先通过计算使用的大小规格，然后使用 <code>mcache</code> 中对应大小规格的块分配</li>
<li>如果对应的大小规格在 <code>mcache</code> 中没有可用的块，向 <code>mcentral</code> 申请</li>
<li>如果 <code>mcentral</code> 也没有可用的块，则向 <code>mheap</code> 申请，并根据 <code>bestFit</code> 算法找到最适合的 <code>mspan</code>，如果申请的 <code>mspan</code> 超出申请大小，会根据需求进行切分，以返回用户需要的页数。剩余的页会构成一个新的 <code>mspan</code> 返回 <code>mheap</code> 的空闲列表。</li>
<li>如果 <code>mheap</code> 没有可用 <code>span</code> 则向操作系统申请一系列新的页（最小 1MB）。</li>
</ol>
<h3><span id="逃逸分析">逃逸分析</span></h3><p><code>Go</code>语言存在 <code>GC</code>，故而不需要自己维护内存。对于一个变量的，编译器会自动决定把一个变量放在栈还是放在堆，<strong>编译器会做逃逸分析(<code>escape analysis</code>)，当发现变量作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆</strong>。</p>
<p>故而这样的代码在 <code>Go</code>合法而 <code>C/C++</code> 不合法：</p>
<pre><code class="language-go">package main

// go:noinline 表示禁止编译器内联
//go:noinline
func test() *int &#123;
    var res1, res2, res3, res4, res5, res6 int
    res1 = 1  
    res2 = 2
    res3 = 3
    res4 = 4
    res5 = 5
    res6 = 6

	// 如果不禁止内联 test 会被内联到 main 中
	// 即使 res3 逃逸到堆上 内存依然会是连续的
    println(&amp;res1, &amp;res2, &amp;res3, &amp;res4, &amp;res5, &amp;res6)

    return &amp;res3
&#125;

func main() &#123;
    mainVal := test()
    println(*mainVal, mainVal)
&#125;

// output
// 0xc000063f08 0xc000063f00 0xc00000a048 0xc000063ef8 0xc000063ef0 0xc000063ee8
// 3 0xc00000a048
</code></pre>
<p>可以使用 <code>go tool compile -m main.go</code> 查看测试（或者通过 <code>go build -gcflags</code>）：</p>
<pre><code class="language-bash"># 禁止内联
⮞  go tool compile -m main.go
main.go:19:6: can inline main
main.go:6:18: moved to heap: res3

# 不禁止内联
⮞  go tool compile -m main.go
main.go:3:6: can inline test
main.go:17:6: can inline main
main.go:18:17: inlining call to test
main.go:4:18: moved to heap: res3
</code></pre>
<p>普遍来说，变量需要使用堆空间，那么他就应该进行逃逸。但是实际上还有很多逃逸现象，比如<strong>给一个引用类对象成员进行赋值</strong>，就大概率会出现逃逸（一般来说：<strong>函数外部没有引用，优先放到栈中，函数外部存在引用，必定放到堆中</strong>）。</p>
<blockquote>
<p>其他的一些内存逃逸的情况：<strong>动态类型赋值、大对象分配、闭包引用</strong>。</p>
</blockquote>
<h3><span id="gc-算法">GC 算法</span></h3><p>栈内存主要用于存储局部遍历和函数调用栈信息，当函数调用结束，栈帧自动出战，其中的局部变量也随之自动被销毁，栈中变量生命周期明确，栈内存自动管理，不需要 <code>GC</code> 介入。</p>
<p>堆内存时程序运行时动态分配的，堆内存上的对象生命周期通常跨函数调用或者被多个部分共享和引用。因此 <code>GC</code> 算法主要用于自动管理堆内存的对象生命周期。</p>
<p>对于 <code>GC</code> 中如何识别可回收对象部分有几种常用解法：</p>
<ul>
<li><strong>引用计数（Reference Counting）</strong>。即所有对象存在相应的引用计数器记录其被引用状态，最后引用计数归零时即成为可回收对象。<ul>
<li>缺点：循环引用问题</li>
<li>解决方案：使用类似标记清除法处理循环引用，或者借助 <code>Tracing GC</code>。</li>
</ul>
</li>
<li><strong>Tracing GC</strong>。 将程序内存分为 <code>GC root</code> 和 <code>GC heap</code> 两部，从 <code>root set</code> 集合作为起点进行图遍历，找到可达对象，回收不可达对象。</li>
</ul>
<p> 基于 <code>Tracing GC</code> 常见 <code>GC</code> 算法有：</p>
<ul>
<li><p><strong>标记清除（Mark-Sweep）</strong>：标记所有需要回收的对象，在标记完成后统一回收所有被标记对象。缺点：容易产生内存碎片问题，导致大对象无法分配。</p>
</li>
<li><p><strong>复制算法（Coping）</strong>：将可用内存按容量划分为大小相等的两块，每次只使用其中其中的一块，当这一块内存用完了就将还存活的对象复制到另一块，再把已使用的内存空间一次清理。缺点：可用内存减少，经常搬运长生命周期对象影响效率。</p>
</li>
<li><p><strong>标记整理（Mark-Compact）</strong>：类似标记清除，但是不止直接堆可回收对象进行清理，而是让所有存活对象向一端移动，然后清理掉边界以外的内存。</p>
</li>
<li><p><strong>分代清理（Generational Collection）</strong>：分代的基本假设：绝大部分对象生命周期都非常短暂，存活时间短。等待算法将堆内存分为新生代和老生代，针对不同年代特定使用不同的收集算法。</p>
</li>
</ul>
<p><code>Go V1.3</code> 之前使用<strong>标记清除</strong>。在执行的过程中，为了保证 <code>GC</code> 的正确性，会需要程序暂停，也就是<code>STW</code>。期间，<code>CPU</code> 不执行用户代码全部用于垃圾回收。所以就会导致程序卡顿。</p>
<p>一个可行的简单优化就是，在清除阶段不再 <code>STW</code> 从而缩短 <code>STW</code>时间减少程序卡顿时长，但是 <code>STW</code> 仍然无可避免。</p>
<p><img src="stw.png" alt="stw"></p>
<p><code>Go V1.5</code> 时堆此进行优化，从单纯的 <strong>标记清除</strong> 改为了 <strong>三色标记法</strong> 来缺点需要清除的对象是哪些。</p>
<p>三色标记法将所有对象分为三类：</p>
<ul>
<li>黑色节点：已经扫描过，并且所有子节点都扫描完了。</li>
<li>灰色节点：已经扫描完，但是子节点未全部扫描完。</li>
<li>白色节点：未扫描。</li>
</ul>
<p>根据 <code>Go</code> 的内存管理模型， <code>GC</code> 扫描从 <strong>根对象（全局数据和协程栈的指针）</strong> 开始，先将根对象放入待扫描队列（灰色），再按照<strong>广度优先</strong>遍历的顺序扫描他们的子节点，将扫描到的子节点加入队列，并将当前节点移除队列，直到待扫描队列为空（即 <strong>不存在灰色对象</strong>），此时剩余的白色对象即为可回收对象。</p>
<blockquote>
<p>执行扫描的协程为 <code>GC Mark Worker</code>，每个<code>P</code> 都会有一个 <code>GC Mark Worker</code>，<code>P</code>数量由 <code>GOMAXPROCS</code>控制，故程序开始时会启动 <code>GOMAXPROCS</code> 个 <code>GC Mark Worker</code>。通过 <code>runtime.MAXPROCS()</code> 动态调整时会发生 <code>STW</code> 。</p>
</blockquote>
<p>因为这期间可能存在很多并发流程被扫描，执行并发流程的内存可能相互依赖，为了保证数据安全，如果在三色标记开始前加上 <code>STW</code> 等最后确定黑白对象之后在放开，这样扫描的效率仍然比较低。</p>
<p>但是如果不使用 <code>STW</code>，可能会导致程序并行的过程，<strong>白色对象被挂在在黑色对象的下游同时其上游不存在其他的灰色对象</strong>，这样就就导致该白色对象无法被扫描到而被当成垃圾回收。因此，如果要减少三色标记的效率，减少 <code>STW</code>就需要破坏这两个条件：</p>
<ul>
<li>白色对象被黑色对象引用。</li>
<li>灰色对象和与其由可达关系的白色对象之间的引用被破坏。</li>
</ul>
<p>不让这两个条件同时成立，就可以避免存在之前提到的情况发生。即 <strong>强弱三色不变式</strong>。</p>
<ul>
<li><strong>强三色不变式</strong>：不存在黑色对象引用到白色对象的指针，即不允许黑色对于引用白色对象。</li>
<li><strong>弱三色不变式</strong>：所有黑色对象引用的白色对象都处于灰色保护状态，即黑色对象对白色对象引用的同时，必须保证白色对象其可达链路上游存在灰色对象。</li>
</ul>
<p>基于此引入了 <strong>屏障机制</strong> ：</p>
<ul>
<li><strong>插入屏障</strong>：在A对象引用B对象的时候，B对象被标记为灰色（<strong>仅在堆内存使用</strong>）。</li>
<li><strong>删除屏障</strong>：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</li>
</ul>
<p>屏障机制破坏了强弱三色不变式，但是也存在一定短板：</p>
<ul>
<li>插入写屏障：结束时需要 <code>STW</code> 重新扫描栈，标记栈引用的白色对象的存活</li>
<li>删除写屏障：回收精度低，<code>GC</code> 开始时需要 <code>STW</code> 扫描栈来记录初始快照</li>
</ul>
<p>因此在 <code>Go V1.8</code> 引入了<strong>混合写屏障</strong>机制，避免了对栈的部分的快照扫描过程，减少了 <code>STW</code> 的时间。具体的操作为：</p>
<ul>
<li><code>GC</code>开始时将栈上对象全部扫描并标记为黑色，后续不再二次重复扫描，无需 <code>STW</code>。</li>
<li><code>GC</code> 期间任何在栈上创建的对象均为黑色</li>
<li>被删除的对象标记为灰色</li>
</ul>
<blockquote>
<p>屏障技术不应用与栈，因为要保证栈的效率</p>
</blockquote>
<p>到目前版本，除开后台的 <code>GC</code> 协程，为了避免内存分配过快时 <code>GC Mark Worker</code> 可能不能及时标记内存，导致内存不能即使回收而无限增长或者长时间 <code>STW</code>，还引入了 <strong>协助标记</strong> 机制。简单来说，即让用户协程在分配内存时也领取一部分标记任务。具体有三个机制：</p>
<ul>
<li><p><strong>信用（Credit）系统</strong>：</p>
<ol>
<li>每个协程维护一个 <code>GC</code> 信用值，表示其需要协助完成的标记工作量</li>
<li><strong>分配内存时扣除信用值</strong>：按分配内存比例减少，分配越多减少的越多</li>
<li><strong>信用耗尽时触发协助</strong>：信用值低于0协程必须执行标记任务来偿还再无，直到信用值恢复为正</li>
</ol>
</li>
<li><p><strong>标记工作量计算</strong>：协程协助的标记工作量和其分配的内存成正比</p>
</li>
<li><p><strong>和后台GC写作</strong>：</p>
<ul>
<li>用户协程协助标记时，会从全局或本地的标记队列中获取对象进行扫描，标记存活对象直到完成自身需承担的标记量</li>
<li>后台<code>GC</code> 协程（如 <code>hcBgMarkWorker</code>）同时运行，处理全局标记</li>
</ul>
</li>
</ul>

    </div>
    
    
    
    
    
    
    <div id="comment">
        <div id="twikoo-container"></div>
    </div>
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 pengqq&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;pengqq
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
    <div>
        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
        <script>
            var now = new Date(); 
            function createtime() { 
                var grt= new Date("03/10/2025 00:00:00");//在此处修改你的建站时间
                now.setTime(now.getTime()+250); 
                days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
            } 
        setInterval("createtime()",250);
        </script>
    </div>
    <div class="busuanzi-count">
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span class="site-uv">
          <i class="fa fa-user"></i>
          总访客 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
          <span class="post-meta-divider"> | </span>
        </span>
        <span class="site-uv">
          <i class="fa fa-eye"></i>
          访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
        </span>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    



<script>
    twikoo.init({
        el: "#twikoo-container",
        envId: "",
        region: "",
        path: location.pathname,
        lang: "",
    })
</script>


    
</body>
</html>