
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | pengqq&#39;s blog</title>
    <meta name="author" content="pengqq" />
    <meta name="description" content="写代码好累..." />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>







<script src="https://s4.zstatic.net/ajax/libs/twikoo/1.6.31/twikoo.all.min.js"></script>



<link rel="stylesheet" href="/css/main.css" />

    <script src="/js/anime.min.js"></script>
    <script src="/js/fireworks.js"></script>
    <script src="/js/sakura.js"></script>
    <link rel="stylesheet" href="/css/cursor.css" />
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>PENGQQ&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;PENGQQ&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/11
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1><span id="golang基础笔记">Golang基础笔记</span></h1><span id="more"></span>

<p>[TOC]</p>
<!-- toc -->

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a><ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85">环境安装</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91">关于编译</a></li>
</ul>
</li>
<li><a href="#%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80">变量基础</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">流程控制</a><ul>
<li><a href="#%E5%88%A4%E6%96%AD">判断</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a></li>
</ul>
</li>
<li><a href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">复合数据类型</a><ul>
<li><a href="#array-%E6%95%B0%E7%BB%84">Array 数组</a></li>
<li><a href="#slice-%E5%88%87%E7%89%87">Slice 切片</a></li>
<li><a href="#map-%E5%AD%97%E5%85%B8">Map 字典</a></li>
<li><a href="#pointer-%E6%8C%87%E9%92%88">Pointer 指针</a></li>
<li><a href="#function-%E5%87%BD%E6%95%B0">Function 函数</a></li>
<li><a href="#struct-%E7%BB%93%E6%9E%84%E4%BD%93">Struct 结构体</a></li>
<li><a href="#channel-%E9%80%9A%E9%81%93">Channel 通道</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95method%E6%8E%A5%E6%94%B6%E8%80%85receiver">方法<code>Method</code>&amp;接收者<code>Receiver</code></a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3-interface">接口 <code>Interface</code></a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%85%B7%E9%93%BE">工具链</a><ul>
<li><a href="#%E5%8C%85%E7%AE%A1%E7%90%86">包管理</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a></li>
</ul>
<!-- tocstop -->

<h2><span id="开发环境">开发环境</span></h2><h3><span id="环境安装">环境安装</span></h3><p><code>Linux</code>安装：</p>
<pre><code class="language-shell">
# 下载指定版本
wget https://golang.google.cn/dl/go1.21.1.linux-amd64.tar.gz

# 解压到指定目录
tar -C /usr/local/ -zxvf go1.21.1.linux-amd64.tar.gz

# 配置环境变量 ~/.bashrc or ~/.profile 添加
export GOROOT=/usr/local/go/bin
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT

# 重新加载配置
source .profile

# 验证
go version
</code></pre>
<p>如果是 <code>Windows</code> 下载安装然后同理配置相关的环境变量即可。</p>
<p>需要注意的是，可以在 <code>GOPATH</code> 目录下新建三个目录 <code>bin</code> 、<code>src</code>、<code>pkg</code>。</p>
<pre><code class="language-shell">$ tree -L 1
.
├── bin
├── pkg
└── src
</code></pre>
<p>在老的版本中，<code>Go</code>项目代码需要存放在 <code>src</code>下，不过目前基本上都使用 <code>go mod</code> 进行管理了，就没有这个限制了。</p>
<h3><span id="关于编译">关于编译</span></h3><p>主要是几个基础命令，详细的构建编译参数可以查看官网。</p>
<pre><code class="language-shell"># 构建
go build [-o outFileName]

# 运行 不输出可执行文件
go run main.go

# 安装 会编译并将代码拷贝到 GOPATH/bin
go install 
</code></pre>
<p>因为<code>Go</code>支持跨平台，大部分代码可以交叉编译：</p>
<pre><code class="language-shell">SET CGO_ENABLED=0  //禁用CGO
SET GOOS=Linux     //目标平台是linux
SET GOARCH=amd     //目标处理架构是amd64
</code></pre>
<p>同时可以在代码源文件顶部添加添加相关注释来声明相应文件在什么环境下会被构建，也就是所谓的<strong>编译约束（或者说条件编译）</strong>。</p>
<pre><code class="language-go">// +build &lt;tag&gt;
// 逗号分开多个Tag表示 AND
// 空格分开多个Tag 表示 OR
// !表示Not
</code></pre>
<p>标签支持的内容有大概下面这些：</p>
<ul>
<li>操作系统，可以参考环境变量 <code>GOOS</code>，比如：<code>linux</code>、<code>windows</code>、<code>darwin</code>。</li>
<li>系统架构，可以参考环境变量 <code>GOARCH</code>，比如 <code>arch64</code>、<code>x86</code>。</li>
<li>使用的编译器：<code>gc</code> 或者 <code>gccgo</code>。</li>
<li>是否开启 <code>CGO</code>，<code>cgo</code>。</li>
<li><code>Go</code>版本号，<code>go1.18</code>等。</li>
<li>忽略编译文件：<code>ignore</code>。</li>
<li>其他自定义标签。</li>
</ul>
<p><strong>需要注意：<code>// +build</code> 下一行必须是空行。</strong></p>
<p>示例：</p>
<pre><code class="language-go">// +build linux, arch64, !cgo

// +build linux darwin

// +build amd64

// +build ignore
</code></pre>
<p>同时也可以使用文件后缀的方式来自动选择编译文件：</p>
<pre><code class="language-bash">$filename_$GOOS.go
$filename_$GOARCH.go
$filename_$GOOS_$GOARCH.go
</code></pre>
<p>通过 <code>ldflags</code> 在编译过程中为变量赋值：</p>
<pre><code class="language-shell">go build -ldflags &quot;-w -s -X main.Version=$&#123;VERSION&#125; -X github.com/demo/version.BuildNo=$&#123;BUILD_NO&#125;&quot;
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>-w</code> ：删除 <code>DWARF</code> 信息，编译出来的程序无法使用 <code>gdb</code> 进行调试。</li>
<li><code>-s</code> ：删除符号表，<code>panic</code> 的 <code>stack trace</code> 没有文件名、行号信息，等价于 <code>C/C++</code> 程序被 <code>strip</code>。</li>
<li><code>-X</code>：替换包中的变量的值</li>
</ul>
<blockquote>
<p>可以通过 <code>-w -s</code> 有效减少编译出来的本地程序大小，但是不利于调试和日志追踪。</p>
</blockquote>
<h2><span id="变量基础">变量基础</span></h2><h3><span id="变量">变量</span></h3><p><code>Go</code> 必须先声明变量再使用。声明方式为：</p>
<pre><code class="language-go">var 变量名 变量类型

// 或者是直接通过类型推导
var 变量名 = 值

// 或者短变量声明 但是该声明只能用于函数内部
变量名 := 值
</code></pre>
<p>一些简单示例：</p>
<pre><code class="language-go">var name string
var isClosed bool
var age int

// 批量声明
var (
	sex int
	height float64
)

// 匿名变量 _
// 不占用命名空间，不分配内存，不存在重复声明。多用于占位，表示忽略值。
// 可以使用匿名变量检查接口是否被实现
var _ FileWriter = (*io.Writer)(nil)
</code></pre>
<h3><span id="常量">常量</span></h3><p>常量在程序运行中恒定不变。使用关键字 <code>const</code> 声明。<code>Go</code>中没有类似 <code>C/C++</code> 的 静态变量 <code>static</code>。</p>
<pre><code class="language-go">const (
	HttpStatusOK = 200
	HttpNotFound = 404
)
</code></pre>
<p>同时提供了常量计数器 <code>iota</code>，其常用于枚举的声明。<code>iota</code> **只能在常量表达式中使用，且在 <code>const</code> 关键字出现时被重置为0 **。</p>
<pre><code class="language-go">
// 批量声明常量时某一行未赋值，默认等于上面一行的值
// 但是可以通过 iota 进行迭代
const (  
    Trace = iota // 0  
    Debug        // 1  
    Info         // 2  
    Warn         // 3  
    Error        // 4  
    Panic        // 5  
    Fatal        // 6  
)
</code></pre>
<h3><span id="数据类型">数据类型</span></h3><p>基础数据类型不多说，看表：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>int64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint8</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint16</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint32</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint64</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>uint</code></td>
<td align="center">操作系统位数对应 <code>uint</code> 位数</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">操作系统位数对应 <code>int</code> 位数</td>
</tr>
<tr>
<td align="center"><code>uintptr</code></td>
<td align="center">无符号整型，用于存放指针</td>
</tr>
<tr>
<td align="center"><code>float32</code></td>
<td align="center">单精度浮点，最大为 <code>math.MaxFloat32</code></td>
</tr>
<tr>
<td align="center"><code>float64</code></td>
<td align="center">双精度浮点，最大为 <code>math.MaxFloat64</code></td>
</tr>
<tr>
<td align="center"><code>bool</code></td>
<td align="center">只支持 <code>true</code> 或者 <code>false</code></td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">字符串为原生数据类型，不可修改。使用 <code>&quot;&quot;</code> 包裹</td>
</tr>
<tr>
<td align="center"><code>byte</code></td>
<td align="center">即 <code>uint8</code>，代表一个 <code>ASCII</code> 字符</td>
</tr>
<tr>
<td align="center"><code>rune</code></td>
<td align="center">代表一个 <code>utf-8</code> 字符</td>
</tr>
</tbody></table>
<h3><span id="运算符">运算符</span></h3><p>算术运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">注意：<strong><code>Go</code>中 自增(<code>++</code>)和自减(<code>--</code>)不是运算符而是语句。</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>关系运算符：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">相等比较，只能比较同类型数据</td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">逻辑运算符，返回一个 <code>bool</code> 类型数据：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">逻辑与</td>
</tr>
<tr>
<td align="center"><code>||</code></td>
<td align="center">逻辑或</td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="center">逻辑非</td>
</tr>
<tr>
<td align="center">位运算符：对整数在内存中的二进制进行操作。</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与，均一为一</td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="center">按位或，有一为一</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或，不同为一</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">有移</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移，高位丢弃，低位补0</td>
</tr>
<tr>
<td align="center">格式化输出占位符：</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>%v</code></td>
<td align="center">按原本值输出</td>
</tr>
<tr>
<td align="center"><code>%+v</code></td>
<td align="center"><code>%v</code>基础上按字段值展开</td>
</tr>
<tr>
<td align="center"><code>%#v</code></td>
<td align="center">输出<code>Go</code>语法格式的值</td>
</tr>
<tr>
<td align="center"><code>%T</code></td>
<td align="center">输出<code>Go</code>语法格式的类型和值</td>
</tr>
<tr>
<td align="center"><code>%%</code></td>
<td align="center">输出<code>%</code></td>
</tr>
<tr>
<td align="center"><code>%b</code></td>
<td align="center">整型以二进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%o</code></td>
<td align="center">整型以八进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%d</code></td>
<td align="center">整型以十进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%x</code></td>
<td align="center">整型以十六进制方式显示</td>
</tr>
<tr>
<td align="center"><code>%X</code></td>
<td align="center">整型以十六进制方式、字母大写显示</td>
</tr>
<tr>
<td align="center"><code>%U</code></td>
<td align="center"><code>Unicode</code>字符</td>
</tr>
<tr>
<td align="center"><code>%f</code></td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center"><code>%p</code></td>
<td align="center">指针，以十六进制显示</td>
</tr>
</tbody></table>
<h2><span id="流程控制">流程控制</span></h2><h3><span id="判断">判断</span></h3><p>经典的 <code>if-else</code>结构和 <code>switch-case</code>结构。</p>
<p>对于 <code>if-else</code> 可以在 <code>if</code> 后定义表达式，将判断条件后置到 <code>;</code> 后。</p>
<pre><code class="language-go">if err := recover(); err != nil &#123;
	// TODO 
&#125;
</code></pre>
<p>对于 <code>switch-case</code>解构，稍有不同，<code>Go</code> 中默认执行完对于匹配的 <code>case</code> 后会自动<code>break</code>。如果想执行下一个 <code>case</code> 需要使用 <code>fallthrough</code>。</p>
<pre><code class="language-go">func (l *LogLevel) unmarshalText(text []byte) bool &#123;  
    switch string(text) &#123;  
    case &quot;trace&quot;, &quot;TRACE&quot;:  
       *l = TraceLevel  
    case &quot;debug&quot;, &quot;DEBUG&quot;:  
       *l = DebugLevel  
    case &quot;info&quot;, &quot;INFO&quot;:  
       *l = InfoLevel  
    case &quot;warn&quot;, &quot;WARN&quot;:  
       *l = WarnLevel  
    case &quot;error&quot;, &quot;ERROR&quot;:  
       *l = ErrorLevel  
    case &quot;panic&quot;, &quot;PANIC&quot;:  
       *l = PanicLevel  
    case &quot;fatal&quot;:
	    fallthrough
    case &quot;FATAL&quot;:  
       *l = FatalLevel  
    default:  
       return false  
    &#125;  
    return true  
&#125;
</code></pre>
<h3><span id="循环">循环</span></h3><p><code>Go</code> 只有 <code>for</code>循环一种循环方式。不过可以使用 <code>for-range</code>循环。可以通过 <code>break</code> 跳出当前循环，通过 <code>continue</code> 结束本次循环。</p>
<pre><code class="language-go">for 循环变量; 循环条件; 变量自增 &#123; 
    // 循环体
&#125;
</code></pre>
<p>关于循环 <code>Go</code> 在 <code>1.22</code> 之前有一个小坑。就是 <code>1.22</code> 之前的 <code>range</code> 循环迭代器的变量都是一个变量，而不是每次创建新变量，虽然提高了效率但是可能存在一些隐患：</p>
<pre><code class="language-go">allItem := make([]*Item, 0)
for _, item := range items &#123;
	allItem = append(allItem, &amp;item)
&#125;

// 此时所有存进去的 item 都是同一个。
// 如果在旧版本想要解决 需要进行一次赋值 v:= v 重新创建变量
allItem := make([]*Item, 0)
for _, item := range items &#123;
	 item := item
	allItem = append(allItem, &amp;item)
&#125;
</code></pre>
<p>同时如果在 <code>goroutine</code> 和闭包环境下，还会产生以下问题：</p>
<pre><code class="language-go">values := []int&#123;1, 2, 3, 4, 5&#125;

for _, val := range values &#123;
	go func() &#123;
		fmt.Printf(&quot;%d &quot;, val)
	&#125;()
&#125;

time.Sleep(time.Second * 3)

// 此时输出会混乱，因为本质上 闭包的 val 都是同一个。
// 可能的输出:
// 5 5 5 5 5
// 所以在旧版本想要修改 需要将循环变量传参进去
values := []int&#123;1, 2, 3, 4, 5&#125;  
for _, val := range values &#123;  
    go func(val int) &#123;  
       fmt.Printf(&quot;%d &quot;, val)  
    &#125;(val)  
&#125;

time.Sleep(time.Second * 3)

// 闭包的情况
var prints []func()  
for _, v := range []int&#123;1, 2, 3&#125; &#123;  
    prints = append(prints, func() &#123; fmt.Println(v) &#125;)  
&#125;
for _, print := range prints &#123;  
    print()  
&#125;
// 输出
// 3 3 3
// 本质上 v 是同一个
</code></pre>
<p>在 <code>go1.21</code> 可以开启 <code>GOEXPERIMENT=loopvar</code> 构建程序，这样会在循环时默认创建新的变量，在 <code>go1.22</code> 以后，默认使用新的循环语义，就没有这个问题了。</p>
<p>同时在 <code>1.22</code> 版本起，<code>range</code> 可以支持对整数类型循环了。</p>
<pre><code class="language-go">for i := range 10 &#123;
	fmt.Println(i)
&#125;
</code></pre>
<h2><span id="复合数据类型">复合数据类型</span></h2><h3><span id="array-数组">Array 数组</span></h3><p>数组是同种数据类型的集合，<strong>数组长度声明时就确定，大小不可变</strong>。</p>
<pre><code class="language-go">var a [6] int
// 数组必须执行元素类型和 容量
// 数组场合都时类型的一部分

// 定义时初始化
var res [2]bool&#123;false, ture&#125;

// 自动根据初始值判断长度
var arr = [...]&#123;1,2,3,4&#125;

// 根据索引初始化 同时自动判断长度
var result = [...]&#123;1:2, 4&#125;

// 定义多维数组
var position = [3][2]int&#123;  
    [2]int&#123;1, 0&#125;,  
    [2]int&#123;1, 1&#125;,  
    [2]int&#123;0, 1&#125;,  
&#125;
</code></pre>
<blockquote>
<p>数组是一个 <strong>值类型</strong>，支持 <code>==</code> 和 <code>!=</code> 运算符，其内存是被初始化过的。</p>
</blockquote>
<h3><span id="slice-切片">Slice 切片</span></h3><p>切片是用于相同类型元素的可变长度序列，支持自动扩容。切片是<strong>引用类型</strong>。</p>
<pre><code class="language-go">// slice 底层结构
type slice struct &#123;  
    array unsafe.Pointer // 数据首地址  
    len   int            // 长度  
    cap   int            // 容量  
&#125;
</code></pre>
<p>切片的常规用法有如下：</p>
<pre><code class="language-go">// 声明
var nums []int // nil

// 创建&amp;初始化
// 通过 func make(t Type, size ...IntegerType) Type 函数初始
// 第二个参数为元素数量
// 第三个参数为底层数组的容量
nums = make([]int, 0, 10)

// 获取容量
capitity := cap(nums)

// 获取长度
length := len(nums)

// 扩容&amp;追加元素到末尾
// 因为其扩容会导致地址变化，需要对切片重新赋值
// func append(slice []T, elements...T) []T
nums = append(nums, 1)

// 切片操作 左闭右开
s1 := nums[:3]
</code></pre>
<p>需要注意：切片是一个引用类型，其指向了一个底层数组，<strong>对于底层数组的修改会改变切片的值</strong>。</p>
<p><img src="slice_01.png" alt="go_slice"></p>
<blockquote>
<p><strong>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断</strong>。</p>
</blockquote>
<p><code>Go1.18</code> 之前扩容以 1024 为临界点，旧容量小于1024时翻倍，大于时循环增加 <code>25%</code> 直到大于期望容量。</p>
<p><code>Go1,18</code>后对于 <code>slice</code>底层的扩容操作可以参考源码 <code>$GOROOT/src/runtime/slice.go</code>：</p>
<pre><code class="language-go">func nextslicecap(newLen, oldCap int) int &#123;  
    newcap := oldCap  
    doublecap := newcap + newcap  
    if newLen &gt; doublecap &#123;  
       return newLen  
    &#125;  
  
    const threshold = 256  
    if oldCap &lt; threshold &#123;  
       return doublecap  
    &#125;  
    for &#123;  
       // Transition from growing 2x for small slices  
       // to growing 1.25x for large slices. This formula       // gives a smooth-ish transition between the two.       
       newcap += (newcap + 3*threshold) &gt;&gt; 2  
  
       // We need to check `newcap &gt;= newLen` and whether `newcap` overflowed.  
       // newLen is guaranteed to be larger than zero, hence       // when newcap overflows then `uint(newcap) &gt; uint(newLen)`.       // This allows to check for both with the same comparison.       if uint(newcap) &gt;= uint(newLen) &#123;  
          break  
       &#125;  
    &#125;  
  
    // Set newcap to the requested cap when  
    // the newcap calculation overflowed.    if newcap &lt;= 0 &#123;  
       return newLen  
    &#125;  
    return newcap  
&#125;
</code></pre>
<p>新版本不再设立临界值，而是设置了一个值为256的<code>threshold</code>。超过256时不再是循环增长 <code>1/4</code>，而是每次增加 <code>(旧容量+3*256)/4</code>。也就是说，其优化了扩容策略，让底层数组大小的增长变得更加平滑，不会再出现系数从 2到 <code>1.25</code> 的突变。</p>
<table>
<thead>
<tr>
<th align="center"><code>oldCap</code></th>
<th align="center">扩容系数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">256</td>
<td align="center">2.0</td>
</tr>
<tr>
<td align="center">512</td>
<td align="center">1.63</td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">1.44</td>
</tr>
<tr>
<td align="center">2048</td>
<td align="center">1.35</td>
</tr>
<tr>
<td align="center">4096</td>
<td align="center">1.30</td>
</tr>
</tbody></table>
<p>求极限扩容系数最后会趋于 <code>1.25</code>。</p>
<p>这么设计的有点是：提高小切片的增长速度，减少内存分配次数，让大切片增长率减小，节省内存。释放的内存更容易被利用。</p>
<p><code>go</code>可以通过 <code>copy</code> 函数来实现对切片的拷贝。但是需要注意，<strong>目标切片必须是要已经初始化内存空间</strong>的。</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
a2 := a1 //赋值  
  
var a3 []int //这样的切片定义是没有初始化内存空间的  
copy(a3, a1)  
  
var a4 = make([]int, len(a1), cap(a1))  
copy(a4, a1)  
  
fmt.Println(a1, a2, a3, a4) //[1 2 3 4 5] [1 2 3 4 5] [] [1 2 3 4 5]
</code></pre>
<p>如果想要实现删除之类的操作，再<code>go1.21</code>版本之前，可以通过下面的方式进行删除：</p>
<pre><code class="language-go">var a1 []int = []int&#123;1, 2, 3, 4, 5&#125;  
  
a3 := append(a1[:1], a1[2:]...) //删除切片中索引为1的元素  
fmt.Println(a1, a3)             //[1 3 4 5],但是底层数组的内容是[1 3 4 5 5]
</code></pre>
<p>但是如果是<code>go1.21</code> 以后，其新增了一个泛型包 <code>slices</code>。其提供了一组相关接口，如 比较、元素查找、修改、克隆等。但是其中的删除操作性能较差，如果需要广泛进行删除，可以考虑使用其他的数据结构。</p>
<h3><span id="map-字典">Map 字典</span></h3><p><code>Go</code> 中的 <code>map</code> 的 <code>key</code> 值必须是 <strong>唯一且无序的</strong>。并且其不能是引用类型或者具有引用语义的数据。</p>
<pre><code class="language-go">// 声明
// var m map[keyType]valueType
var set map[int]struct&#123;&#125; // 此时并未分配内存

// 可以通过 make 进行初始化和初始容量的分配
set = make(map[int]struct&#123;&#125;, 10)
set[1] = struct&#123;&#125;&#123;&#125;

// 获取 map 值时可以获取两个数据
// 第二个值表示是否获取到 其是可选的
val, ok := set[1];

// 如果需要删除一个键值对 可以使用 delete()
// 第二个参数为一个 key 值
delete(set, 10)
</code></pre>
<p>同样的，在 <code>go1.21</code> 也引入了 <code>maps</code> 泛型包提供了一组对 <code>map</code> 的操作集合，比如 克隆、拷贝、比较、删除等等。</p>
<p>同时在 <code>go1.24</code> 之前的版本中，<code>go</code> 对于 <code>map</code> 的底层实现是基于 <code>hash table</code>，同时使用拉链法来处理哈希冲突。</p>
<pre><code class="language-go">// runtime/map.go  
// A header for a Go map.  
type hmap struct &#123;  
    count     int // 当前哈希表中的元素数量  
    flags     uint8  
    B         uint8  // 当前哈希表持有的 buckets 数量, 因为哈希表中桶的数量都按2倍扩容,改字段存储对数，也就是 len(buckets) == 2^B    noverflow uint16 // 溢出桶的大致数量  
    hash0     uint32 // hash seed  
  
    buckets    unsafe.Pointer // 存储 2^B 个桶的数组  
    oldbuckets unsafe.Pointer // 扩容时用于保存之前 buckets 的字段 , 大小事buckets的一般  
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)  
    extra *mapextra // optional fields  
&#125;  
  
// mapextra 主要维护，当hmap中的buckets中有一些桶发生溢出，但有达不到扩容阈值时，存储溢出的桶  
type mapextra struct &#123;  
    overflow    *[]*bmap  
    oldoverflow *[]*bmap  
  
    // nextOverflow holds a pointer to a free overflow bucket.    nextOverflow *bmap  
&#125;
</code></pre>
<p>其在<code>map</code>元素达到阈值时会进行扩容操作，主要时两个条件：</p>
<ul>
<li>装载因子（元素数量&#x2F;桶数量）超过阈值</li>
<li>使用了太多的溢出桶</li>
</ul>
<p>并且其扩容流程大概为：</p>
<ol>
<li>新桶数组：分配通常为原先2倍的更大的桶数组，便于分散键值对，减少哈希冲突</li>
<li>重新哈希：遍历旧的桶数组的所有键值对，重新计算哈希并插入到新桶数组</li>
<li>逐步迁移：避免扩容时性能和效率问题，迁移可能时逐步的，扩容期间新、旧桶数组会同时存在，新插入的键值对直接插入新桶数组，对旧桶数组的数据的迁移会在访问时触发</li>
<li>更新状态：所有数组完成迁移会更新内部状态以反映新的结构</li>
</ol>
<p>但是在 <code>go1.24</code>版本后，<code>map</code>的底层实现有优化，从 <code>hash table</code> 变成了 <code>Swiss table</code>。</p>
<p>对于 <code>SwissTable</code>的一些更详细的数据结构的解释可以参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">SwissTable</a></p>
<p><code>SwissTable</code> 基于改进的线性探测法的哈希表实现，通过改进哈希表结构和元数据存储，优化了性能和内存使用。</p>
<p>参考源码：<a target="_blank" rel="noopener" href="https://github.com/dolthub/swiss">SwissGo</a> 或者是 <code>go1.24</code>后版本 <code>runtime\maps\map.go</code>。</p>
<blockquote>
<p>如果想使用原来的 <code>map</code> 可以使用 <code>GOEXPERIMENT=noswissmap</code></p>
</blockquote>
<p>部分源码如下：</p>
<pre><code class="language-go">// swiss map
type Map struct &#123;
    // 填充槽的数量（即所有表中元素的数量） 不包括已删除的槽位
    // 必须是第一个（由编译器知道，对于len()内置）
    used uint64
    // 哈希种子
    seed uintptr
    // 指向一个table指针数组 dirPtr *[dirLen]*table
    // 长度 dirLen 是 1 左移 globalDepth
    // 对 小map的优化: 如果map始终包含 abi.SwissMapGroupSlots 或者更少条目
    // dirPtr 直接指向一个组 dirPtr *group
    // 这种情况下 dirLen = 0
    //used 计算组中已使用的槽位数量(小map永远没有已删除槽位,因为没有需要维护的探测序列)
    dirPtr unsafe.Pointer
    dirLen int
    // 在表目录查找中使用的位数
    globalDepth uint8
    //在目录查找时要从哈希中移出的位数
    //在64位系统上，这是64- globalDepth
    globalShift uint8
    // writing是在写入映射时被切换（异或1）的标志
    // 通常在写入时将其设置为1，但如果有多个并发写入器，那么切换会增加双方都检测到竞争的概率
    writing uint8
    // clearSeq是调用Clear的序列计数器。它用于在迭代期间检测映射清除
    clearSeq uint64
&#125;
</code></pre>
<p>他的扩容采用了扩展哈希(<code>Extendible Hashing</code>)，通过多级目录和表拆分，将扩容开销分摊到多次操作中。</p>
<p>即当 单个表容量达到 <code>maxTableCapacity(默认1024)</code>时触发动态扩容。</p>
<ol>
<li>拆分时会创建两个子表(<code>table left</code>和 <code>table right</code>)，其深度<code>localDepth</code>比原表大1，表示其哈希掩码多使用了一个高位比特</li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1043
func (t *table) split(typ *abi.SwissMapType, m *Map) &#123;
    localDepth := t.localDepth
    localDepth++ // 子表的 localDepth 比原表大 1
    left := newTable(typ, maxTableCapacity, -1, localDepth)
    right := newTable(typ, maxTableCapacity, -1, localDepth)
    // ...
&#125;
</code></pre>
<ol start="2">
<li>根据哈希的高位比特将原表的数据分配到左表和右表。会计算一个掩码，掩码的生成依赖于 <code>localDepth</code></li>
</ol>
<pre><code class="language-go">//https://github.com/golang/go/blob/3f4164f508b8148eb526fc096884dba2609f5835/src/internal/runtime/maps/table.go#L1052
mask := localDepthMask(localDepth) // 生成掩码，例如 0x80000000（第 32 位）
for ... &#123;
    hash := typ.Hasher(key, m.seed)
    if hash &amp; mask == 0 &#123;
        left.uncheckedPutSlot(...) // 分配到左表
    &#125; else &#123;
        right.uncheckedPutSlot(...) // 分配到右表
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>完成拆分后更新全局目录 ，使原表的索引范围指向新的子表，如果原表的 <code>localDepth</code> 等于全局的 <code>localDepth</code> 则目录需要翻倍。</li>
</ol>
<pre><code class="language-go">// map.go
func (m *Map) installTableSplit(old, left, right *table) &#123;
    if old.localDepth == m.globalDepth &#123;
        // 目录扩展：大小翻倍
        newDir := make([]*table, m.dirLen*2)
        // 复制旧目录项并指向新表
        for i := range m.dirLen &#123;
            newDir[2*i] = left
            newDir[2*i+1] = right
        &#125;
        m.dirPtr = unsafe.Pointer(&amp;newDir[0])
        m.globalDepth++
    &#125; else &#123;
        // 不扩展目录，仅替换部分项
        entries := 1 &lt;&lt; (m.globalDepth - left.localDepth)
        for i := 0; i &lt; entries; i++ &#123;
            m.directorySet(uintptr(old.index+i), left)
            m.directorySet(uintptr(old.index+i+entries), right)
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>虽然新结构大部分情况下提高了性能，但是部分情况下可能降低，比如 <code>map[key]struct&#123;&#125;</code></p>
</blockquote>
<h3><span id="pointer-指针">Pointer 指针</span></h3><p><code>Go</code>中保留了指针概念，但是对指针的操作进行了限制。常规的指针用法只有：</p>
<ul>
<li><code>&amp;</code> 取地址</li>
<li><code>*</code> 寻址(解引用)</li>
</ul>
<p>大部分情况下的使用跟 <code>C</code> 是类似的。如果要分配内存可以使用 <code>new</code> 为指针申请内存，对于一些特殊的结构 <code>slice、map、channel</code> 可以使用 <code>make</code> 赋初值进行初始化。</p>
<p>但是和<code>C/C++</code>不同，其返回一个局部变量的地址是安全的（存在引用计数）。</p>
<pre><code class="language-go">var a *int // nil 
var b new(int) // int 类型默认值

*b = 100

// 返回局部变量指针
func newInt() *int &#123;
	a := 3
	return &amp;a
&#125;
</code></pre>
<blockquote>
<p>需要注意，对空指针操作会引起 恐慌 <code>Panic</code></p>
</blockquote>
<p><code>Go</code>中对指针的限制在于：</p>
<ul>
<li>不支持算术运算 (<code>p++</code>操作时不合法的，但是 <code>*p++</code> 可以编译通过，视为 <code>(*p)++</code>)</li>
<li>不支持随意转为另一个指针类型，即其<strong>底层类型</strong>必须一致(自定义类型底层类型相同时可以隐式转换)。</li>
<li>不能和其他任意指针类型的值进行比较，只能在指针类型相同或者时可以被隐式转换时，或者和空指针 <code>nil</code> 进行比较时才支持比较操作。</li>
</ul>
<p>但是这些限制并不是绝对的，可以通过 <code>unsafe.Pointer</code> 机制打破这些限制。<code>unsafe.Pointer</code> 类似于 <code>C/C++</code> 的 <code>void*</code>，其同样使用 <code>nil</code> 表示零值声明。</p>
<p>同时 <code>unsafe.Pointer</code> 的滥用可能导致其值的生命周期被修改导致内存泄漏，并且由于 <code>gc</code> 时间的不确定性，应该慎用。</p>
<blockquote>
<p><code>unsafe</code> 包不被保证版本兼容性</p>
</blockquote>
<h3><span id="function-函数">Function 函数</span></h3><p>函数声明使用 <code>func</code> 关键字，函数名为一个标识符，而后时形参表和返回值列表。<br>如果需要调用某函数，使用函数名加上<code>()</code>。</p>
<p><code>Go</code>函数支持变长参数，但是变长参数只能放到参数表的最后，在函数体内，变长参数被视为一个切片。同时，函数参数不支持设置默认值，所有参数都要求被显示传递。</p>
<p>示例：</p>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
)  
  
func Sum(x int, y int) (ret int) &#123;  
    ret = x + y  
    return ret  
    //使用命名返回值return后可以为空  
&#125;  
  
// Println 可变长参数  
// 可变长参数必须放在函数的最后  
func Println(s string, x ...int) &#123;  
    fmt.Println(s, x) //name [1 2 2 3 5]  
    //x是对应类型的切片  
&#125;  
  
// 命名函数中不能声明命名函数  
func main() &#123;  
    ret := Sum(1, 2)  
    fmt.Println(ret)  
  
    Println(&quot;name&quot;, 1, 2, 2, 3, 5)  
&#125;
</code></pre>
<blockquote>
<p>注意：所有的函数传参都是值传递</p>
</blockquote>
<p>在函数内部不能声明命名函数，只能定义<strong>匿名函数</strong>，其定义不包括函数名称部分，其他没有太大区别。同时，匿名函数的形参会遮挡外部环境的变量。</p>
<p>同时，也引出闭包概念：<strong>即一个函数对象，它能够访问并操作其定义时所在作用域中的变量，即使这个函数在其定义的作用域之外被调用</strong>。</p>
<pre><code class="language-go">// 外部函数，返回一个闭包  
func createCounter() func() int &#123;  
    count := 0 // 外部函数的变量  
  
    // 内部函数，闭包  
    return func() int &#123;  
       count++ // 修改外部函数的变量  
       return count  
    &#125;  
&#125;
</code></pre>
<p>其的特点是：</p>
<ul>
<li>访问外部作用域的变量</li>
<li>保持变量状态</li>
<li>本质上是一个函数对象</li>
</ul>
<p>可以借助闭包来隐藏一些内部实现的细节，但是滥用可能会导致内存泄漏问题。</p>
<p>相对特殊的，<code>Go</code>的函数调用存在一个退出阶段：即函数调用返回后，此调用可能并未立即退出。这个阶段的意义主要在于<strong>延迟函数 <code>defer</code></strong>。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func main() &#123;  
    defer fmt.Println(&quot;The third line.&quot;)  
  
    defer fmt.Println(&quot;The second line.&quot;)  
  
    fmt.Println(&quot;The first line.&quot;)  
&#125;

//The first line.  
//The second line.  
//The third line.

// 可以通过延迟操作修改最内侧函数的返回值
func Triple(n int) (r int) &#123;  
    defer func() &#123;  
       r += n // 修改返回值  
    &#125;()  
    return n + n // &lt;=&gt; r = n + n; return  
&#125;
</code></pre>
<p>也就是说：<code>go</code>的 <code>return</code> 操作并不是原子操作，而是：返回值赋值 <code>-&gt;</code> <code>defer</code> 执行 <code>-&gt;</code> 真正返回 的流程。</p>
<p>延迟函数的主要应用场景在于对一些资源的释放，比如对于网络资源的释放、锁的释放等。同时，配合内建函数 <code>panic</code> 和 <code>recover</code> 可以实现类似 <code>try-catch</code> 的效果。</p>
<p>如果函数内注册了多个 <code>defer</code>函数，最终结果会按照注册顺序逆序执行。</p>
<pre><code class="language-go">package main  
  
import &quot;fmt&quot;  
  
func A() &#123;  
    fmt.Println(&quot;A&quot;)  
&#125;  
  
func B() &#123;  
    //defer用来执行释放连接  
    defer func() &#123;  
       err := recover()  
       //recover会尝试恢复panic之前的操作并向后执行  
       fmt.Println(err)  
       fmt.Println(&quot;释放连接。。&quot;)  
    &#125;()  
    panic(&quot;ERROR!!&quot;) //程序崩溃退出  
    fmt.Println(&quot;B&quot;)  
&#125;  
  
func C() &#123;  
    fmt.Println(&quot;C&quot;)  
&#125;  
  
func main() &#123;  
    A()  
    B()  
    C()  
    //A  
    //ERROR!!    //释放连接。。  
    //C  
&#125;
</code></pre>
<p><code>panic</code>：提供的一种报告致命错误的方式，<code>panic</code> 发生时会中断程序运行。</p>
<p><code>recover</code>：拦截运行时 <code>panic</code>，重新获取流程控制权，并返回 <code>panic value</code>。未发生<code>panic</code>会返回 <code>nil</code>。</p>
<blockquote>
<p>注意， <code>recover</code>必须搭配 <code>defer</code> 使用。<code>defer</code> 必须在可能 <code>panic</code> 之前定义，<code>recover</code> 才能拦截到。</p>
</blockquote>
<h3><span id="struct-结构体">Struct 结构体</span></h3><p><code>Go</code> 可以使用 <code>type</code> 关键字声明类型别名或者自定义类型。</p>
<pre><code class="language-go">type LogLevel int

type MyInt int64
</code></pre>
<p>结构体是一种自定义类型，由<code>type</code>和 <code>struct</code> 关键字和 一对 <code>&#123;&#125;</code> 包含一组结构体成员构成（可以不使用 <code>type</code> 关键字声明无名结构体）。</p>
<p>同时需要注意，<code>Go</code> 未设置 <code>public</code>、<code>private</code> 类似的访问修饰符，所以采用了根据首字母大小写区分内部字段释放导出（首字母大写为导出，否则仅包内部可见，函数同样如此）。</p>
<pre><code class="language-go">struct &#123;
	want: 0,
	got: 1,
	args: []
&#125;

type Logger &#123;
	io.Writer
	Filename string
&#125;
</code></pre>
<p>对于<code>Go</code>来说，结构体的尺寸为它所有字段的尺寸加上可能的填充的字节数（通常编译器会在结构体值的两个相邻字段直接填充一些字节来保证一些字段的地址总是某个整数的倍数）。</p>
<blockquote>
<p>特殊的：空结构体的尺寸为零。</p>
</blockquote>
<p>同时每个结构体可以被指定一个标签 <code>tag</code>。语法上来说，这个标签可以是任意的，默认为空字符串，实践过程中其应该被表示为一个 <strong>空格分隔的键值对</strong>形式。</p>
<pre><code class="language-go">type LogOptions struct &#123;  
    // 输出日志等级  
    Level LogLevel `json:&quot;level&quot;`  
    // 日期输出格式  
    Layout string `json:&quot;layout&quot;`  
  
    // 文本格式输出前缀  
    TextPrefix string `json:&quot;text_prefix&quot;`  
    // 日志输出格式标志  
    TextFlag LTextFlag `json:&quot;text_flag&quot;`  

    // Json格式一些默认字段的key  
    TimeEncodeKey    string `json:&quot;time_encode_key&quot;`  
    SourceEncodeKey  string `json:&quot;source_encode_key&quot;`  
    LevelEncodeKey   string `json:&quot;level_encode_key&quot;`  
    MessageEncodeKey string `json:&quot;message_encode_key&quot;`  
    FieldEncodeKey   string `json:&quot;field_encode_key&quot;`  
&#125;
</code></pre>
<p>这些 <code>tag</code> 在相关的序列化和反序列化中常用，比如 <code>json</code> 、<code>xml</code>。如果想要获取这些 <code>tag</code> 的值可以 通过反射。</p>
<blockquote>
<p><code>Go</code> 不存在 <code>Union</code> 联合体</p>
</blockquote>
<h3><span id="channel-通道">Channel 通道</span></h3><p>通道主要是配合协程实现并发同步。他的设计理念是：<strong>不要让计算通过共享内存来通讯，而是应该让他们通过通信来共享内存</strong>。</p>
<p>而 <code>channel</code> 可以视为一个 <strong>先进先出(<code>FIFO: first in first out</code>)队列</strong>。一些协程向此通道发送数据，由另一些协程进行处理。</p>
<p>随着一个数据值的传递，一些数据值的所有权从一个协程转移到了另一个协程。即协程发送一个值到<code>channel</code> 可以视为此协程释放了一些值的所有权，协程从通道接受到一个值，可以认为此协程获取了一些值的所有权（也可能没有任何所有权发生转移）。</p>
<p>通道分为单项和双向：</p>
<ul>
<li><code>chan T</code>：视为元素类型<code>T</code> 的双向通道，编译器允许从其接收和发送数据。</li>
<li><code>chan&lt;- T</code>：视为元素类型 <code>T</code> 的单向发送通道，编译器只允许向其发送数据。</li>
<li><code>&lt;-chan T</code>：视为元素类型 <code>T</code> 的单向接收通道，编译器只允许从其接收数据。</li>
</ul>
<pre><code class="language-go">package main  
  
import (  
    &quot;fmt&quot;  
)  
  
func Scanner(in chan&lt;- string) &#123;  
    // 只允许发送数据  
    for i := 0; i &lt; 20; i++ &#123;  
       in &lt;- &quot;Hello World!&quot;  
    &#125;  
    close(in)  
&#125;  
  
func Printer(out &lt;-chan string) &#123;  
    for msg := range out &#123;  
       fmt.Println(msg)  
    &#125;  
&#125;  
  
func Processor(out &lt;-chan string, in chan&lt;- string) &#123;  
    for msg := range out &#123;  
       in &lt;- msg  
    &#125;  
    close(in)  
&#125;  
  
func main() &#123;  
    in := make(chan string)  
    go Scanner(in)  
    out := make(chan string)  
    go Processor(in, out)  
  
    Printer(out)  
&#125;
</code></pre>
<p><strong>所有的通道均为可比较类型</strong>。其值为引用类型，通道的赋值会使得多个通道值共享底层部分。</p>
<p>通道有几个基本操作：</p>
<ul>
<li>关闭 ，通过内建函数<code>close</code></li>
</ul>
<pre><code class="language-go">close(ch)
</code></pre>
<ul>
<li>发送，需要注意，其不能为单向接收通道，<code>&lt;-</code> 为数据发送操作符</li>
</ul>
<pre><code class="language-go">ch &lt;- v
</code></pre>
<ul>
<li>接收，需要注意，其不能为单向接收通道，<code>&lt;-</code> 为数据接收操作符。如果一个通道操作不永久阻塞，其至少会返回一个值。</li>
</ul>
<pre><code class="language-go">v := &lt;- ch

// ok 表示第一个值释放时通道被关闭之前返回的
v, ok := &lt;- ch
</code></pre>
<ul>
<li>查询容量</li>
</ul>
<pre><code class="language-go">cap(ch)
</code></pre>
<ul>
<li>查询通道长度</li>
</ul>
<pre><code class="language-go">len(ch)
</code></pre>
<blockquote>
<p>通道操作都是并发安全的。</p>
</blockquote>
<p>对不同状态的通道进行相关操作会得到不同的结果，可以参考下表：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">零值(<code>nil</code>)通道</th>
<th align="center">非零值已关闭</th>
<th align="center">非零值未关闭</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关闭</td>
<td align="center"><code>panic</code></td>
<td align="center"><code>panic</code></td>
<td align="center">成功关闭</td>
</tr>
<tr>
<td align="center">发送数据</td>
<td align="center">永久阻塞</td>
<td align="center"><code>panic</code></td>
<td align="center">阻塞或者发送成功</td>
</tr>
<tr>
<td align="center">接收数据</td>
<td align="center">永久阻塞</td>
<td align="center">永不阻塞</td>
<td align="center">阻塞或成功接收</td>
</tr>
<tr>
<td align="center"><strong>通道的元素值的传递都是复制过程</strong>，从一个协程传递到另一个协程，此值被复制至少一遍。如果值传递过程中在某个通道的缓存队列中停留过，则在传递过程中被复制两次，一次在推入通道队列的时候，一次为从缓冲队列取出的时候。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>官方编译器最大支持的通道元素类型尺寸为 <code>65535</code>，值传递的过程中，只有直接值被复制。</p>
</blockquote>
<p>可以使用 <code>for-range</code> 来循环从通道中接收元素直到通道关闭并且他的缓冲队列为空。不同于 <code>slice</code>、<code>map</code>，通道只能出现一个循环变量用于存储接收到的值。</p>
<pre><code class="language-go">for v := range ch &#123;
	// todo
&#125;
</code></pre>
<p>同时为 <code>channel</code> 专门设计了 <code>select-case</code> 分支流程控制语法（类似与 <code>switch-case</code>）。对于 <code>select-case</code>中的所有非阻塞的 <code>case</code>，会<strong>随机</strong>选择一个执行，如果所有的 <code>case</code> 都阻塞且未添加 <code>default</code> 分支，会阻塞当前协程。</p>
<pre><code class="language-go">package main  
  
import (  
    &quot;context&quot;  
    &quot;fmt&quot;    &quot;time&quot;)  
  
func main() &#123;  
    ctx, ctxCancel := context.WithCancel(context.Background())  
    ticker := time.NewTicker(time.Second)  
    for &#123;  
       select &#123;  
       case &lt;-ctx.Done():  
          fmt.Println(&quot;exit&quot;)  
          return  
       case &lt;-ticker.C:  
          fmt.Println(&quot;tick&quot;)  
          ctxCancel()  
       &#125;  
    &#125;  
&#125;
</code></pre>
<p>对于 <code>select-case</code>流程的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/select.go">实现机制</a>：</p>
<ol>
<li><p>将所有 <code>case</code> 中的 通道表达式和发送值表达式按照 从上到下、从左到右 的顺序估值。在赋值语句中作为源值的数据接收操作对应的目标值在此时不需要被估值。</p>
</li>
<li><p>将所有的分支随机排序，<code>default</code> 总是在最后。所有<code>case</code> 操作的通道可能是重复的。</p>
</li>
<li><p>为了防止下一步操作中出现死锁，对所有的 <code>case</code> 操作中相关的通道进行排序（这个顺序并不重要，官方编译器使用通道的地址顺序进行排序），排序前<code>N</code>个（<code>N</code>为<code>case</code>中涉及到的不重复通道数）通道不存在重复情况。</p>
</li>
<li><p>按照上一步生产的通道锁顺序获取所有相关的通道的锁。（<strong>通道锁顺序</strong>是针对排序结果中前 <code>N</code>个通道来说的，<strong>通道锁逆序</strong>是指此顺序的逆序）</p>
</li>
<li><p>按照随机排序后的<code>case</code>分支顺序来顺序检查相应分支：</p>
<ol>
<li>如果是 <code>case</code> 且 相应通道操作是向已关闭通道发送数据，则根据<strong>通道锁逆序</strong>解锁所有通道并在当前协程产生 <code>panic</code>，结束。</li>
<li>如果是 <code>case</code> 且 相应通道非阻塞，按照<strong>通道锁逆序</strong>解锁所有通道并执行相应的 <code>case</code> 分支代码块（此操作可能会唤醒另一个阻塞的协程），结束。</li>
<li>如果是 <code>default</code>，按照<strong>通道锁逆序</strong>解锁所有通道，并执行 <code>default</code>代码，结束。</li>
</ol>
</li>
<li><p>如果 <code>default</code> 不存在且所有的 <code>case</code> 均阻塞，将当前协程（包含对应的 <code>case</code>信息）推入每个 <code>case</code> 对应的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong>。（当前协程可能多次被推入同一个通道的这两个队列中，因为多个·<code>case</code> 操作对应的通道可能为同一个）</p>
</li>
<li><p>当前协程进入阻塞状态并按照<strong>通道锁逆序</strong>解锁所有通道。</p>
</li>
<li><p>等待其他协程通过通道操作唤醒当前协程。</p>
</li>
<li><p>如果被其他协程的通道操作唤醒，目标操作可能是关闭通道或者数据的接收或者发送操作。</p>
<ol>
<li>如果是数据发送或者接收操作，执行对应<code>case</code>，过程中当前协程将从对应的<code>case</code>操作相关的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong> <strong>弹出</strong>。</li>
</ol>
</li>
<li><p>按照<strong>通道锁顺序</strong>获取所有相关通道的锁。</p>
</li>
<li><p>将当前协程从各个 <code>case</code> 操作中对应的通道的 <strong>发送数据协程队列</strong> 或者 <strong>接收数据协程队列</strong>  （可能以非弹出的方式）<strong>移除</strong>。<br>1. 如果是被关闭操作唤醒，执行5<br>2. 如果是被数据发送&#x2F;数据接收操作唤醒，目标<code>case</code>在9中已经知晓。按照<strong>通道锁逆序</strong>解锁所有通道并执行目标 <code>case</code>。</p>
</li>
<li><p>结束。</p>
</li>
</ol>
<h2><span id="面向对象">面向对象</span></h2><h3><span id="方法methodamp接收者receiver">方法<code>Method</code>&amp;接收者<code>Receiver</code></span></h3><p><code>Go</code>没有 <code>Class</code> 但是支持一些面向对象的特性。比如为类型 <code>T</code> 和 <code>*T</code> 显示地声明一个方法（方法基本上跟函数类似），其中类型 <code>T</code> 必须满足条件：</p>
<ol>
<li>需要是一个自定义类型</li>
<li><code>T</code>类型需要和方法声明在同一个包</li>
<li><code>T</code> 不能是一个指针或者接口类型</li>
</ol>
<p>类型<code>T</code>和 <code>*T</code> 即为各自方法的属主（接收者）类型。类型 <code>T</code>为 <code>T</code> 和 <code>*T</code> 声明的所有方法的属主基类型。如果为类型声明了某方法，即该类型拥有此方法。</p>
<p>每个方法对应着一个隐式声明的函数：</p>
<pre><code class="language-go">type Book struct &#123;  
    pages int  
&#125;  
  
func (b Book) Pages() int &#123;  
    return b.pages  
&#125;  
func (b *Book) SetPages(pages int) &#123;  
    b.pages = pages  
&#125;

// 对应隐式函数 
// 由此也可以看出，如果需要修改接收者变量的数据，请使用指针接收者
func Book.Pages(b Book) int &#123;  
    return b.pages // 此函数体和Book类型的Pages方法体一样  
&#125;  
func (*Book).SetPages(b *Book, pages int) &#123;  
    b.pages = pages // 此函数体和*Book类型的SetPages方法体一样  
&#125;
</code></pre>
<blockquote>
<p>这种类型函数只能由编译器隐式声明。</p>
</blockquote>
<p>如果需要实现面向对象的继承效果，可以通过结构体嵌套实现模拟（同时注意嵌套结构体的字段冲突）。</p>
<pre><code class="language-go">type commonHandler struct &#123;  
    mutex       sync.Mutex  
    writeSyncer io.Writer  
    opts        *LogHandlerOptions  
&#125;

type JsonHandler struct &#123;  
    *commonHandler  
&#125;

type TextHandler struct &#123;  
    *commonHandler  
&#125;
</code></pre>
<h3><span id="接口-interface">接口 <code>Interface</code></span></h3><p>接口是一种特殊的类型，其可以包裹非接口值实现反射、多态。同时在 <code>go1.18</code>开始，自定义泛型被引入， 接口类型也可以用作泛型约束。</p>
<p>这也导致了 <code>go1.18</code>之前所有的接口与均可用作值类型，<code>go1.18</code>以后，有些接口只能用作类型约束。可用于值类型的接口成为基本接口类型（这里主要是基本接口类型）。</p>
<p>接口类型是通过内嵌若干接口元素来定义类型条件的，目前支持两种接口元素：方法元素和类型元素。</p>
<pre><code class="language-go">type error interface &#123;  
    Error() string  
&#125;

// go1.18之前 只有接口类型可以内勤在接口类型中
// 即接口多继承
type WriteSyncer interface &#123;  
    io.WriteCloser  
    Sync() error  
&#125;

// go1.18以后  接口类型可以作为泛型约束
// PointerConstraint 指针类型泛型约束  
type PointerConstraint[T any] interface &#123;  
    ~*T  
&#125;  
  
type Option[T PointerConstraint[U], U any] interface &#123;  
    Apply(T)  
&#125;  
  
type optionFunc[T PointerConstraint[U], U any] func(T)  
  
func (f optionFunc[T, U]) Apply(o T) &#123;  
    f(o)  
&#125;  
  
type options struct &#123;  
    name string  
&#125;  
  
func WithOptions(name string) Option[*options, options] &#123;  
    return optionFunc[*options, options](func(o *options) &#123;  
       o.name = name  
    &#125;)  
&#125;
</code></pre>
<blockquote>
<p>需要注意：接口实现是隐式的，其关注行为而非类型。</p>
</blockquote>
<p>空接口是一个特殊的接口类型，其没有内嵌任何方法或类型。同时在 <code>Go1.18</code>引入了空接口的类型别名 <code>any</code>。</p>
<p><strong>因为空接口不包含任何方法，因此所有类型都实现了空接口</strong>。</p>
<pre><code class="language-go">type any = interface&#123;&#125;
</code></pre>
<p>一个接口值中存储的动态类型信息可以被用来检视此接口值的动态值和操纵此动态值所引用的值。 这称为反射。</p>
<p>针对接口，我们常用的是<strong>类型断言</strong>。语法格式为 <code>i.(T)</code>，其中 <code>i</code> 为一个接口值，<code>T</code> 为一个类型名或者自定义类型（可以为任意一个非接口类型或者任意一个接口类型）。</p>
<pre><code class="language-go">func test() &#123;  
    // 编译器将把123的类型推断为内置类型int。  
    var x interface&#123;&#125; = 123  
    // 情形一：  
    n, ok := x.(int)  
    fmt.Println(n, ok) // 123 true  
    n = x.(int)  
    fmt.Println(n) // 123  
    // 情形二：  
    a, ok := x.(float64)  
    fmt.Println(a, ok) // 0 false  
    // 情形三：  
    a = x.(float64) // 将产生一个恐慌  
&#125;
</code></pre>
<p>如果出现针对接口值相关的比较：</p>
<ul>
<li>比较一个接口值和非接口值</li>
<li>比较两个接口</li>
</ul>
<p>对于非接口值的类型，必须实现了接口值的类型，所以可以隐式转换为两个接口的比较。而比较两个接口值，即比较两个接口值的动态类型和动态值：</p>
<ol>
<li>其中一个接口时 <code>nil</code> ，则比较另一个接口是否也为 <code>nil</code></li>
<li>如果这两个接口值的动态类型不一样，则比较结果为 <code>false</code></li>
<li>如果其动态类型一样：<ol>
<li>动态类型为不可比较类型，<code>panic</code></li>
<li>比较动态值的比较结果</li>
</ol>
</li>
</ol>
<p>即：只有两个接口都为 <code>nil</code> 或者两个接口的动态值、动态类型相同为可比较类型且动态值相等时为 <code>true</code>。</p>
<p><code>Go</code> 中针对非空接口和接口底层上有两种实现，即 <code>iface</code> 和 <code>eface</code>。其中 <code>eface</code> 即 <code>empty interface</code> 表示不含 <code>method</code> 的接口（也就是空接口）。</p>
<pre><code class="language-go">type _type struct &#123;  
    size       uintptr  // type size  
    ptrdata    uintptr  // size of memory prefix holding all pointers    
    hash       uint32   // hash of type; avoids computation in hash tables    
    tflag      tflag    // extra type information flags  
    align      uint8    // alignment of variable with this type  
    fieldalign uint8    // alignment of struct field with this type  
    kind       uint8    // enumeration for C  
    alg        *typeAlg // algorithm table  
    gcdata     *byte    // garbage collection data  
    str        nameOff  // string form  
    ptrToThis  typeOff  // type for pointer to this type, may be zero  
&#125;

type eface struct &#123;
	// 数据类型的描述
    _type *_type
    // 具体的类型
    data  unsafe.Pointer  
&#125;

// layout of Itab known to compilers  
// allocated in non-garbage-collected memory  
// Needs to be in sync with  
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.  
type itab struct &#123;  
    inter  *interfacetype  
    _type  *_type  
    link   *itab  
    bad    int32  
    inhash int32      // has this itab been added to hash?    fun    [1]uintptr // variable sized  
&#125;

type iface struct &#123;
	// 接口元信息 可以理解为 pair&lt;接口类型, 具体类型&gt;
    tab  *itab  
    data unsafe.Pointer  
&#125;
</code></pre>
<h2><span id="工具链">工具链</span></h2><h3><span id="包管理">包管理</span></h3><p><code>Go</code>中的包定义必须在代码开始之前，使用 <code>package</code> 关键字定义。（其之前可能存在相关的编译约束）</p>
<pre><code class="language-go">//go:build linux  
// +build linux  
  
package utils
</code></pre>
<p>包的定义有如下规则：</p>
<h2><span id="异步编程">异步编程</span></h2>
    </div>
    
    
    
    
    
    
    <div id="comment">
        <div id="twikoo-container"></div>
    </div>
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 pengqq&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;pengqq
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
    <div>
        <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
        <script>
            var now = new Date(); 
            function createtime() { 
                var grt= new Date("03/10/2025 00:00:00");//在此处修改你的建站时间
                now.setTime(now.getTime()+250); 
                days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
                document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
            } 
        setInterval("createtime()",250);
        </script>
    </div>
    <div class="busuanzi-count">
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span class="site-uv">
          <i class="fa fa-user"></i>
          总访客 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
          <span class="post-meta-divider"> | </span>
        </span>
        <span class="site-uv">
          <i class="fa fa-eye"></i>
          访问量 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
        </span>
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    



<script>
    twikoo.init({
        el: "#twikoo-container",
        envId: "",
        region: "",
        path: location.pathname,
        lang: "",
    })
</script>


    
</body>
</html>